<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Apophis v27 - Single File Build</title>
<style>
/* APOPHIS - Styles */

body {
    margin: 0;
    background: #000;
    overflow: hidden;
    font-family: 'Courier New', Courier, monospace;
}

canvas {
    display: block;
    cursor: none;
}

#hud {
    position: absolute;
    top: 20px;
    left: 20px;
    color: #00ffff;
    font-size: 24px;
    text-shadow: 0 0 10px #00ffff;
    z-index: 10;
}

#levelDisplay {
    position: absolute;
    top: 60px;
    left: 20px;
    color: #ff00ff;
    font-size: 20px;
    text-shadow: 0 0 10px #ff00ff;
    z-index: 10;
}

#sector {
    position: absolute;
    top: 20px;
    right: 20px;
    color: #ff00ff;
    font-size: 20px;
    text-shadow: 0 0 10px #ff00ff;
    z-index: 10;
}

#alert {
    position: absolute;
    top: 20%;
    left: 50%;
    transform: translateX(-50%);
    color: #ffffff;
    font-size: 40px;
    text-shadow: 0 0 20px #fff;
    display: none;
    z-index: 15;
    pointer-events: none;
    text-align: center;
}

#instructions {
    position: absolute;
    bottom: 20px;
    left: 20px;
    color: #00ffff;
    font-size: 14px;
    text-shadow: 0 0 5px #00ffff;
    z-index: 10;
}

#version {
    position: absolute;
    bottom: 20px;
    right: 20px;
    color: #00ffff;
    font-size: 14px;
    text-shadow: 0 0 5px #00ffff;
    z-index: 10;
}

#overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #000;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 20;
}

#titleCanvas {
    width: 100%;
    height: 100%;
}
</style>
</head>
<body>
<div id="overlay">
<canvas id="titleCanvas"></canvas>
</div>
<div id="alert">TRENCH RUN ACTIVATED</div>
<div id="hud">Score: <span id="score">0</span></div>
<div id="levelDisplay">LEVEL: <span id="levelNum">1</span></div>
<div id="sector">SECTOR: OPEN SPACE</div>
<div id="instructions">
‚Üê‚Üí/AD Move | Z/SPACE Shoot | V Missile | X Shield | C Boomba | ‚Üë‚Üì/WS Weapon | R Restart
</div>
<div id="version">APOPHIS v27.0</div>
<canvas id="gameCanvas"></canvas>
<script>
// ========== js/config.js ==========
// APOPHIS - Configuration & Constants
// Frame rate control
const TARGET_FPS = 60;
const FRAME_DURATION = 1000 / TARGET_FPS; // ~16.67ms per frame
// Field of view scale for 3D perspective
const FOV_SCALE = 0.75;
// Enemy spawn lanes (for 3D chapters)
const ENEMY_WORLD_LANES = [-350, -220, -120, 0, 120, 220, 350];
// Missile system
const MAX_MISSILE_AMMO = 10;
const MISSILE_COOLDOWN_FRAMES = 30;
// Boss bullet firing sequence
const BOSS_BULLET_SEQUENCE = [6, 7, 2];
// Chapter durations (in frames at 60fps)
const CHAPTER_DURATION = 1200; // 20 seconds
// Player settings
const MAX_HEALTH = 3;
const STARTING_LIVES = 3;
const SHIELD_MAX = 100;
const SHIELD_DRAIN_RATE = 0.5;
const SHIELD_REGEN_RATE = 0.05;
// Boomba settings
const MAX_BOOMBA_QUEUE = 40;
const BOOMBA_CHARGE_MAX = 300;
const BOOMBA_CHARGE_RATE = 2;
// Invulnerability durations (frames)
const INVULN_PICKUP_DURATION = 600; // 10 seconds
const INVULN_RESPAWN_DURATION = 180; // 3 seconds
// Timers (frames)
const RESPAWN_TIMER_DURATION = 120; // 2 seconds
const DEATH_TIMER_DURATION = 180; // 3 seconds
const BOSS_DEFEATED_TIMER = 180; // 3 seconds
const LEVEL_TRANSITION_TIMER = 180; // 3 seconds
const CHAPTER_TRANSITION_TIMER = 120; // 2 seconds
// Score values
const SCORE_ENEMY = 50;
const SCORE_BLOCKDOT = 200;
const SCORE_MINIBOSS = 1000;
const SCORE_BOSS = 5000;
const SCORE_OBSTACLE = 100;
const SCORE_DEFLECT_BULLET = 5;
// Weapon definitions
const WEAPONS = {
    DEFAULT: 0,
    SINE_WAVE: 1,
    SCATTER: 2,
    LASER: 3
};
const WEAPON_NAMES = ['DEFAULT', 'SINE WAVE', 'SCATTER', 'LASER'];
const WEAPON_ICONS = ['D', 'S', 'C', 'L'];
// Fire rate (frames between shots)
const FIRE_DELAY = 6;
// Mini-boss configurations by level
const MINIBOSS_CONFIGS = [
    { fireRate: 20, chaosRate: 0.03, defense: 0.05, color1: '#ff0000', color2: '#ffff00', bulletType: 'line' },
    { fireRate: 15, chaosRate: 0.08, defense: 0.08, color1: '#ff0000', color2: '#0088ff', bulletType: 'circle' },
    { fireRate: 25, chaosRate: 0.02, defense: 0.12, color1: '#ff0000', color2: '#00ff00', bulletType: 'triangle' }
];
// Chapter names
const CHAPTER_NAMES = ['OPEN SPACE', 'PLANETSIDE', 'TRENCH CANYON', 'BOSS SECTOR'];
// Particle colors
const EXPLOSION_COLORS = ['#00ffff', '#ff00ff', '#ffffff', '#ffff00'];
const DAMAGE_EXPLOSION_COLORS = ['#ff0000', '#ff6600', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
const MEGA_EXPLOSION_COLORS = ['#ff0000', '#ff6600', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#00ff00', '#ff0066', '#6600ff', '#ff3300'];
// Area boomba radius
const AREA_BOOMBA_RADIUS = 400;

// ========== js/state.js ==========
// APOPHIS - Game State
// All mutable game state lives here
// Canvas and rendering context (set by main.js)
let canvas = null;
let ctx = null;
// DOM element references (set by main.js)
let scoreEl = null;
let levelEl = null;
let sectorEl = null;
let alertEl = null;
let overlay = null;
// Title screen
let titleCanvas = null;
let titleCtx = null;
let titleStars = [];
let titleTime = 0;
let titleAnimationId = null;
// Screen dimensions
let width = 0;
let height = 0;
// Core game state
let gameSpeed = 0.08;
let score = 0;
let gameOver = false;
let time = 0;
// Ship state
let shipX = 0;
let shipY = 0;
let shipAngle = 0;
// Game object arrays
let bullets = [];
let enemies = [];
let particles = [];
let stars = [];
let pickups = [];
let trenchBlocks = [];
let hearts = [];
let harassers = [];
let harasserBullets = [];
let miniBosses = [];
let miniBossBullets = [];
let missiles = [];
// Shield system
let shieldLevel = 100;
let shieldActive = false;
// Health system
let health = 3;
let lives = 3;
let deathTimer = 0;
let respawnTimer = 0;
// Level/chapter progression
let level = 1;
let chapter = 1;
let chapterTimer = 0;
// Boss state
let bossActive = false;
let bossDefeatedTimer = 0;
let bossScoreGained = 0;
let bossBulletBurst = 0;
let bossBulletPhase = 0;
let bossBulletCooldown = 0;
// Transition timers
let levelTransitionTimer = 0;
let chapterTransitionTimer = 0;
// Weapons
let currentWeapon = 0;
let weaponInventory = [0];
// Boomba system
let boombaQueue = [];
let chargingBoomba = false;
let boombaCharge = 0;
// Invulnerability
let invulnerabilityTimer = 0;
// Missile system
let missileAmmo = 3;
let missileCooldown = 0;
// Frame timing
let lastFrameTime = 0;
let accumulator = 0;
// Input state
const keys = {};
// Gamepad state
let gamepadConnected = false;
let gamepad = null;
let gamepadButtons = {};
let gamepadPrevButtons = {};
let debugGamepad = false;
// Audio state (references set by audio.js)
let audioCtx = null;
let engineOsc = null;
let engineGain = null;
let bossOsc = null;
let bossGain = null;
// =============================================================================
// State Setters - Functions to modify state from other modules
// =============================================================================
function setCanvas(c, context) {
    canvas = c;
    ctx = context;
}
function setDOMElements(elements) {
    scoreEl = elements.scoreEl;
    levelEl = elements.levelEl;
    sectorEl = elements.sectorEl;
    alertEl = elements.alertEl;
    overlay = elements.overlay;
}
function setTitleCanvas(c, context) {
    titleCanvas = c;
    titleCtx = context;
}
function setTitleStars(s) { titleStars = s; }
function setTitleTime(t) { titleTime = t; }
function incrementTitleTime() { titleTime++; }
function setTitleAnimationId(id) { titleAnimationId = id; }
function setDimensions(w, h) {
    width = w;
    height = h;
}
function setGameSpeed(speed) { gameSpeed = speed; }
function incrementGameSpeed(amount) { gameSpeed += amount; }
function setScore(s) { 
    score = s; 
    if (scoreEl) scoreEl.textContent = score;
}
function addScore(amount) { 
    score += amount; 
    if (scoreEl) scoreEl.textContent = score;
}
function setGameOver(value) { gameOver = value; }
function setTime(t) { time = t; }
function incrementTime() { time++; }
function setShipPosition(x, y) {
    shipX = x;
    shipY = y;
}
function setShipX(x) { shipX = x; }
function setShipY(y) { shipY = y; }
function setShipAngle(angle) { shipAngle = angle; }
function adjustShipAngle(delta) { shipAngle += delta; }
function dampenShipAngle(factor) { shipAngle *= factor; }
function setBullets(b) { bullets = b; }
function setEnemies(e) { enemies = e; }
function setParticles(p) { particles = p; }
function setStars(s) { stars = s; }
function setPickups(p) { pickups = p; }
function setTrenchBlocks(t) { trenchBlocks = t; }
function setHearts(h) { hearts = h; }
function setHarassers(h) { harassers = h; }
function setHarasserBullets(hb) { harasserBullets = hb; }
function setMiniBosses(mb) { miniBosses = mb; }
function setMiniBossBullets(mbb) { miniBossBullets = mbb; }
function setMissiles(m) { missiles = m; }
function setShieldLevel(level) { shieldLevel = level; }
function adjustShieldLevel(amount) { shieldLevel = Math.max(0, Math.min(100, shieldLevel + amount)); }
function setShieldActive(active) { shieldActive = active; }
function setHealth(h) { health = h; }
function adjustHealth(amount) { health = Math.max(0, Math.min(MAX_HEALTH, health + amount)); }
function setLives(l) { lives = l; }
function adjustLives(amount) { lives += amount; }
function setDeathTimer(t) { deathTimer = t; }
function decrementDeathTimer() { if (deathTimer > 0) deathTimer--; }
function setRespawnTimer(t) { respawnTimer = t; }
function decrementRespawnTimer() { if (respawnTimer > 0) respawnTimer--; }
function setLevel(l) { 
    level = l; 
    if (levelEl) levelEl.textContent = level;
}
function incrementLevel() { 
    level++; 
    if (levelEl) levelEl.textContent = level;
}
function setChapter(c) { chapter = c; }
function incrementChapter() { chapter++; }
function setChapterTimer(t) { chapterTimer = t; }
function incrementChapterTimer() { chapterTimer++; }
function setBossActive(active) { bossActive = active; }
function setBossDefeatedTimer(t) { bossDefeatedTimer = t; }
function decrementBossDefeatedTimer() { if (bossDefeatedTimer > 0) bossDefeatedTimer--; }
function setBossScoreGained(s) { bossScoreGained = s; }
function setBossBulletBurst(b) { bossBulletBurst = b; }
function incrementBossBulletBurst() { bossBulletBurst++; }
function setBossBulletPhase(p) { bossBulletPhase = p; }
function advanceBossBulletPhase() { bossBulletPhase = (bossBulletPhase + 1) % 3; }
function setBossBulletCooldown(c) { bossBulletCooldown = c; }
function decrementBossBulletCooldown() { if (bossBulletCooldown > 0) bossBulletCooldown--; }
function setLevelTransitionTimer(t) { levelTransitionTimer = t; }
function decrementLevelTransitionTimer() { if (levelTransitionTimer > 0) levelTransitionTimer--; }
function setChapterTransitionTimer(t) { chapterTransitionTimer = t; }
function decrementChapterTransitionTimer() { if (chapterTransitionTimer > 0) chapterTransitionTimer--; }
function setCurrentWeapon(w) { currentWeapon = w; }
function cycleWeaponNext() { currentWeapon = (currentWeapon + 1) % weaponInventory.length; }
function cycleWeaponPrev() { currentWeapon = (currentWeapon - 1 + weaponInventory.length) % weaponInventory.length; }
function setWeaponInventory(inv) { weaponInventory = inv; }
function addWeapon(weapon) { 
    if (!weaponInventory.includes(weapon)) {
        weaponInventory.push(weapon);
    }
}
function setBoombaQueue(queue) { boombaQueue = queue; }
function addBoomba(type) { 
    if (boombaQueue.length < MAX_BOOMBA_QUEUE) {
        boombaQueue.push(type);
    }
}
function shiftBoomba() { return boombaQueue.shift(); }
function setChargingBoomba(charging) { chargingBoomba = charging; }
function setBoombaCharge(charge) { boombaCharge = charge; }
function incrementBoombaCharge(amount = BOOMBA_CHARGE_RATE) { 
    boombaCharge = Math.min(boombaCharge + amount, BOOMBA_CHARGE_MAX); 
}
function setInvulnerabilityTimer(t) { invulnerabilityTimer = t; }
function decrementInvulnerabilityTimer() { if (invulnerabilityTimer > 0) invulnerabilityTimer--; }
function setMissileAmmo(ammo) { missileAmmo = ammo; }
function adjustMissileAmmo(amount) { missileAmmo = Math.max(0, Math.min(MAX_MISSILE_AMMO, missileAmmo + amount)); }
function setMissileCooldown(c) { missileCooldown = c; }
function decrementMissileCooldown() { if (missileCooldown > 0) missileCooldown--; }
function setLastFrameTime(t) { lastFrameTime = t; }
function setAccumulator(a) { accumulator = a; }
function adjustAccumulator(amount) { accumulator += amount; }
function setKey(code, value) { keys[code] = value; }
function setGamepadConnected(connected) { gamepadConnected = connected; }
function setGamepad(gp) { gamepad = gp; }
function setGamepadButtons(buttons) { gamepadButtons = buttons; }
function setGamepadPrevButtons(buttons) { gamepadPrevButtons = buttons; }
function setDebugGamepad(debug) { debugGamepad = debug; }
function setAudioContext(ctx) { audioCtx = ctx; }
function setEngineOsc(osc) { engineOsc = osc; }
function setEngineGain(gain) { engineGain = gain; }
function setBossOsc(osc) { bossOsc = osc; }
function setBossGain(gain) { bossGain = gain; }
// =============================================================================
// Reset function for game initialization
// =============================================================================
function resetGameState() {
    gameSpeed = 0.08;
    score = 0;
    gameOver = false;
    time = 0;
    
    bullets = [];
    enemies = [];
    particles = [];
    pickups = [];
    trenchBlocks = [];
    hearts = [];
    harassers = [];
    harasserBullets = [];
    miniBosses = [];
    miniBossBullets = [];
    missiles = [];
    
    shipAngle = 0;
    shieldLevel = 100;
    shieldActive = false;
    health = MAX_HEALTH;
    lives = STARTING_LIVES;
    deathTimer = 0;
    respawnTimer = 0;
    
    level = 1;
    chapter = 1;
    chapterTimer = 0;
    
    bossActive = false;
    bossDefeatedTimer = 0;
    bossScoreGained = 0;
    bossBulletBurst = 0;
    bossBulletPhase = 0;
    bossBulletCooldown = 0;
    
    levelTransitionTimer = 0;
    chapterTransitionTimer = 0;
    
    currentWeapon = 0;
    weaponInventory = [0];
    
    boombaQueue = [];
    chargingBoomba = false;
    boombaCharge = 0;
    
    invulnerabilityTimer = 0;
    
    missileAmmo = 3;
    missileCooldown = 0;
    
    if (scoreEl) scoreEl.textContent = score;
    if (levelEl) levelEl.textContent = level;
}

// ========== js/audio.js ==========
// APOPHIS - Audio System
// Web Audio API sound generation
/**
 * Initialize the audio context and persistent oscillators
 */
function initAudio() {
    if (audioCtx) return;
    
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    setAudioContext(ctx);
    
    // Engine sound - persistent oscillator
    const engineOsc = ctx.createOscillator();
    const engineGain = ctx.createGain();
    engineOsc.type = 'sawtooth';
    engineOsc.frequency.setValueAtTime(45, ctx.currentTime);
    engineGain.gain.setValueAtTime(0, ctx.currentTime);
    engineOsc.connect(engineGain);
    engineGain.connect(ctx.destination);
    engineOsc.start();
    setEngineOsc(engineOsc);
    setEngineGain(engineGain);
    
    // Boss sound - persistent oscillator
    const bossOsc = ctx.createOscillator();
    const bossGain = ctx.createGain();
    bossOsc.type = 'triangle';
    bossOsc.frequency.setValueAtTime(100, ctx.currentTime);
    bossGain.gain.setValueAtTime(0, ctx.currentTime);
    bossOsc.connect(bossGain);
    bossGain.connect(ctx.destination);
    bossOsc.start();
    setBossOsc(bossOsc);
    setBossGain(bossGain);
}
/**
 * Update the engine and boss ambient sounds based on game state
 */
function updateEngineSound() {
    if (!audioCtx || gameOver || 
        levelTransitionTimer > 0 || 
        chapterTransitionTimer > 0 || 
        bossDefeatedTimer > 0) {
        
        if (engineGain) {
            engineGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
        }
        if (bossGain) {
            bossGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
        }
        return;
    }
    
    // Engine sound responds to movement and shield
    engineGain.gain.setTargetAtTime(
        shieldActive ? 0.15 : 0.06, 
        audioCtx.currentTime, 
        0.1
    );
    
    const pitchShift = 45 + (Math.abs(shipAngle) * 80) + (shieldActive ? 20 : 0);
    engineOsc.frequency.setTargetAtTime(pitchShift, audioCtx.currentTime, 0.05);
    
    // Boss sound - follows boss movement
    if (harassers.length > 0) {
        const boss = harassers[0];
        const bossFreq = 100 + (boss.x / width) * 100 + Math.sin(boss.phase * 2) * 30;
        bossOsc.frequency.setTargetAtTime(bossFreq, audioCtx.currentTime, 0.05);
        bossGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.1);
    } else {
        bossGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
    }
}
/**
 * Play a one-shot sound effect
 * @param {number} freq - Frequency in Hz
 * @param {string} type - Oscillator type ('sine', 'square', 'sawtooth', 'triangle')
 * @param {number} dur - Duration in seconds
 * @param {number} vol - Volume (0-1)
 */
function playSound(freq, type, dur, vol) {
    if (!audioCtx) return;
    
    const osc = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    
    osc.type = type;
    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
    
    // Square waves get a frequency sweep
    if (type === 'square') {
        osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + dur);
    }
    
    g.gain.setValueAtTime(vol, audioCtx.currentTime);
    g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + dur);
    
    osc.connect(g);
    g.connect(audioCtx.destination);
    
    osc.start();
    osc.stop(audioCtx.currentTime + dur);
}
// Sound effect presets
const SFX = {
    // Weapon sounds
    shoot: () => playSound(800, 'square', 0.1, 0.05),
    shootSine: () => playSound(900, 'sine', 0.1, 0.05),
    shootScatter: () => playSound(700, 'square', 0.15, 0.08),
    shootLaser: () => playSound(1200, 'sawtooth', 0.2, 0.1),
    
    // Missile sounds
    missilelaunch: () => {
        playSound(150, 'sawtooth', 0.4, 0.25);
        playSound(80, 'square', 0.3, 0.15);
    },
    missileHit: () => {
        playSound(60, 'sawtooth', 0.6, 0.4);
        playSound(120, 'square', 0.4, 0.3);
    },
    
    // Impact sounds
    enemyHit: () => playSound(150, 'sawtooth', 0.2, 0.1),
    enemyDestroy: () => playSound(100, 'sine', 0.1, 0.2),
    bossHit: () => playSound(400, 'square', 0.05, 0.1),
    bossDestroy: () => playSound(50, 'sawtooth', 1.5, 0.5),
    
    // Damage sounds
    playerHit: () => playSound(50, 'sawtooth', 0.5, 0.3),
    trenchCollision: () => playSound(40, 'sawtooth', 0.8, 0.4),
    
    // Deflection sounds
    bulletDeflect: () => playSound(1200, 'sine', 0.05, 0.08),
    missileDeflect: () => {
        playSound(1200, 'sine', 0.05, 0.08);
        playSound(1200, 'sine', 0.08, 0.12);
    },
    blockDeflect: () => playSound(800, 'sine', 0.05, 0.06),
    
    // Pickup sounds
    pickup: () => playSound(600, 'sine', 0.3, 0.2),
    pickupMissile: () => playSound(550, 'sine', 0.3, 0.2),
    pickupExtraLife: () => playSound(900, 'sine', 0.5, 0.3),
    pickupHealth: () => playSound(800, 'sine', 0.3, 0.2),
    boombaDrop: () => playSound(400, 'sine', 0.3, 0.15),
    
    // Boomba sounds
    boombaArea: () => playSound(120, 'square', 0.6, 0.3),
    boombaScreen: () => playSound(60, 'square', 1.2, 0.4),
    boombaCharged: () => playSound(80, 'square', 1.0, 0.3),
    
    // Boss bullet sounds
    bossBullet: () => playSound(200, 'sine', 0.1, 0.03),
    miniBossBullet: () => playSound(250, 'sine', 0.08, 0.04)
};

// ========== js/input.js ==========
// APOPHIS - Input Handling
// Keyboard and gamepad input management
/**
 * Initialize input event listeners
 */
function initInput() {
    // Keyboard events
    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    
    // Gamepad events
    window.addEventListener('gamepadconnected', handleGamepadConnected);
    window.addEventListener('gamepaddisconnected', handleGamepadDisconnected);
}
/**
 * Handle key down events
 */
function handleKeyDown(e) {
    setKey(e.code, true);
    
    // Prevent default for space to avoid page scroll
    if (e.code === 'Space') {
        e.preventDefault();
    }
}
/**
 * Handle key up events
 */
function handleKeyUp(e) {
    setKey(e.code, false);
}
/**
 * Handle gamepad connection
 */
function handleGamepadConnected(e) {
    setGamepadConnected(true);
    console.log('Gamepad connected:', e.gamepad.id);
    console.log('Gamepad has', e.gamepad.buttons.length, 'buttons and', e.gamepad.axes.length, 'axes');
    console.log('To debug gamepad inputs, set debugGamepad = true');
    updateInstructionsDisplay();
}
/**
 * Handle gamepad disconnection
 */
function handleGamepadDisconnected(e) {
    setGamepadConnected(false);
    setGamepad(null);
    console.log('Gamepad disconnected');
    updateInstructionsDisplay();
}
/**
 * Update the instructions display based on input method
 */
function updateInstructionsDisplay() {
    const instructionsEl = document.getElementById('instructions');
    if (!instructionsEl) return;
    
    if (gamepadConnected) {
        instructionsEl.innerHTML = 'üéÆ Controller: D-Pad/L-Stick Move | A Shoot | X Missile | B Shield | Y Boomba | L/R Weapon | Start Restart';
    } else {
        instructionsEl.innerHTML = '‚Üê‚Üí/AD Move | Z/SPACE Shoot | V Missile | X Shield | C Boomba | ‚Üë‚Üì/WS Weapon | R Restart';
    }
}
/**
 * Poll gamepad state - call each frame
 */
function pollGamepad() {
    if (!gamepadConnected) {
        if (debugGamepad) console.log('pollGamepad: not connected');
        return;
    }
    if (debugGamepad && Math.random() < 0.01) {
        console.log('pollGamepad: running...');
    }
    const gamepads = navigator.getGamepads();
    let gamepad = null;
    // Find the first connected gamepad
    for (let i = 0; i < gamepads.length; i++) {
        if (gamepads[i]) {
            gamepad = gamepads[i];
            break;
        }
    }
    if (!gamepad) {
        setGamepadConnected(false);
        return;
    }
    setGamepad(gamepad);
    // Store previous button states
    setGamepadPrevButtons({...gamepadButtons});
    // D-pad support (check both buttons and axes)
    let dpadLeft = false, dpadRight = false, dpadUp = false, dpadDown = false;
    // Check D-pad as buttons (12-15)
    if (gamepad.buttons[12]) dpadUp = gamepad.buttons[12].pressed;
    if (gamepad.buttons[13]) dpadDown = gamepad.buttons[13].pressed;
    if (gamepad.buttons[14]) dpadLeft = gamepad.buttons[14].pressed;
    if (gamepad.buttons[15]) dpadRight = gamepad.buttons[15].pressed;
    // Check D-pad as axes (common on Switch Pro Controller and others)
    if (gamepad.axes[6] !== undefined) {
        if (gamepad.axes[6] < -0.5) dpadLeft = true;
        if (gamepad.axes[6] > 0.5) dpadRight = true;
    }
    if (gamepad.axes[7] !== undefined) {
        if (gamepad.axes[7] < -0.5) dpadUp = true;
        if (gamepad.axes[7] > 0.5) dpadDown = true;
    }
    // Alternative axes (9.x for some controllers)
    if (gamepad.axes[9] !== undefined) {
        if (gamepad.axes[9] < -0.5) dpadLeft = true;
        if (gamepad.axes[9] > 0.5) dpadRight = true;
    }
    const buttons = {
        shoot: gamepad.buttons[0]?.pressed || false,    // A button (or B on Switch)
        shield: gamepad.buttons[1]?.pressed || false,   // B button (or A on Switch)
        missile: gamepad.buttons[2]?.pressed || false,  // X button (or Y on Switch)
        boomba: gamepad.buttons[3]?.pressed || false,   // Y button (or X on Switch)
        weaponPrev: gamepad.buttons[4]?.pressed || false, // LB
        weaponNext: gamepad.buttons[5]?.pressed || false, // RB
        restart: gamepad.buttons[9]?.pressed || false,  // Start button
        // D-pad (unified from buttons and axes)
        dpadUp: dpadUp,
        dpadDown: dpadDown,
        dpadLeft: dpadLeft,
        dpadRight: dpadRight,
        // Left stick axes
        leftStickX: gamepad.axes[0] || 0,
        leftStickY: gamepad.axes[1] || 0
    };
    setGamepadButtons(buttons);
    // Debug logging
    if (debugGamepad && (Object.values(buttons).some(v => v === true || Math.abs(v) > 0.5))) {
        console.log('Gamepad state:', {
            buttons: Object.entries(buttons).filter(([k,v]) => v === true || Math.abs(v) > 0.5),
            rawAxes: Array.from(gamepad.axes).map((v, i) => `${i}:${v.toFixed(2)}`).filter(s => !s.endsWith('0.00'))
        });
    }
}
/**
 * Check if a gamepad button was just pressed this frame
 */
function isGamepadButtonJustPressed(button) {
    return gamepadButtons[button] && !gamepadPrevButtons[button];
}
/**
 * Check if movement left is pressed (keyboard or gamepad)
 */
function isMovingLeft() {
    return keys['ArrowLeft'] || keys['KeyA'] || gamepadButtons.dpadLeft;
}
/**
 * Check if movement right is pressed (keyboard or gamepad)
 */
function isMovingRight() {
    return keys['ArrowRight'] || keys['KeyD'] || gamepadButtons.dpadRight;
}
/**
 * Check if fire button is pressed (keyboard or gamepad)
 */
function isFiring() {
    return keys['KeyZ'] || keys['Space'] || gamepadButtons.shoot;
}
/**
 * Check if shield button is pressed (keyboard or gamepad)
 */
function isShielding() {
    return keys['KeyX'] || gamepadButtons.shield;
}
/**
 * Check if boomba button is pressed (keyboard or gamepad)
 */
function isBoombaPresseed() {
    return keys['KeyC'] || gamepadButtons.boomba;
}
/**
 * Check if missile key was pressed (keyboard only - gamepad handled separately)
 */
function isMissileKeyPressed() {
    return keys['KeyV'];
}
/**
 * Check if restart key is pressed
 */
function isRestartPressed() {
    return keys['KeyR'] || isGamepadButtonJustPressed('restart');
}
/**
 * Check weapon cycle up
 */
function isWeaponUpPressed() {
    return keys['ArrowUp'] || keys['KeyW'];
}
/**
 * Check weapon cycle down
 */
function isWeaponDownPressed() {
    return keys['ArrowDown'] || keys['KeyS'];
}
/**
 * Get left stick X axis value (with deadzone)
 */
function getLeftStickX() {
    const value = gamepadButtons.leftStickX || 0;
    const deadzone = 0.2;
    return Math.abs(value) > deadzone ? value : 0;
}

// ========== js/title.js ==========
// APOPHIS - Title Screen
// Title screen initialization and rendering
/**
 * Initialize the title screen
 */
function initTitleScreen() {
    const titleCanvas = document.getElementById('titleCanvas');
    const titleCtx = titleCanvas.getContext('2d');
    
    titleCanvas.width = window.innerWidth;
    titleCanvas.height = window.innerHeight;
    
    setTitleCanvas(titleCanvas, titleCtx);
    
    // Create twinkling stars
    const stars = [];
    for (let i = 0; i < 200; i++) {
        stars.push({
            x: Math.random() * titleCanvas.width,
            y: Math.random() * titleCanvas.height,
            size: Math.random() * 2 + 0.5,
            twinkleSpeed: Math.random() * 0.05 + 0.02,
            twinkleOffset: Math.random() * Math.PI * 2
        });
    }
    setTitleStars(stars);
    setTitleTime(0);
    
    renderTitleScreen();
}
/**
 * Main title screen render loop
 */
function renderTitleScreen() {
    const titleCanvas = titleCanvas;
    const titleCtx = titleCtx;
    const titleStars = titleStars;
    
    const w = titleCanvas.width;
    const h = titleCanvas.height;
    incrementTitleTime();
    const titleTime = titleTime;
    
    // Clear
    titleCtx.fillStyle = '#000';
    titleCtx.fillRect(0, 0, w, h);
    
    // Draw twinkling stars
    titleStars.forEach(star => {
        const twinkle = Math.sin(titleTime * star.twinkleSpeed + star.twinkleOffset);
        const alpha = 0.3 + twinkle * 0.7;
        const size = star.size * (0.8 + twinkle * 0.4);
        titleCtx.fillStyle = `rgba(255, 255, 255, ${Math.max(0, alpha)})`;
        titleCtx.beginPath();
        titleCtx.arc(star.x, star.y, size, 0, Math.PI * 2);
        titleCtx.fill();
    });
    
    // Calculate center and scaling - fit everything on screen
    const centerX = w / 2;
    const scale = Math.min(w / 800, h / 600);
    const lineHeight = 38 * scale;
    const startY = 30 * scale;
    
    // Title with color cycling glow
    const hue = (titleTime * 2) % 360;
    titleCtx.font = `bold ${42 * scale}px Courier New`;
    titleCtx.textAlign = 'center';
    titleCtx.shadowBlur = 30;
    titleCtx.shadowColor = `hsl(${hue}, 100%, 50%)`;
    titleCtx.fillStyle = '#00ffff';
    titleCtx.fillText('A P O P H I S', centerX, startY + lineHeight);
    
    titleCtx.font = `${12 * scale}px Courier New`;
    titleCtx.shadowBlur = 10;
    titleCtx.shadowColor = '#ff00ff';
    titleCtx.fillStyle = '#ff00ff';
    titleCtx.fillText('STEERING COMMITTEE-27', centerX, startY + lineHeight * 1.5);
    
    // Section: ENEMIES
    let y = startY + lineHeight * 2.3;
    titleCtx.font = `bold ${16 * scale}px Courier New`;
    titleCtx.shadowBlur = 15;
    titleCtx.shadowColor = '#ff0000';
    titleCtx.fillStyle = '#ff0000';
    titleCtx.fillText('‚Äî ENEMIES ‚Äî', centerX, y);
    
    y += lineHeight * 0.8;
    const col1 = centerX - 160 * scale;
    const col2 = centerX - 100 * scale;
    const col3 = centerX + 50 * scale;
    const col4 = centerX + 100 * scale;
    
    titleCtx.font = `${13 * scale}px Courier New`;
    titleCtx.textAlign = 'left';
    
    // Enemy (square)
    drawTitleEnemy(titleCtx, col1, y, scale);
    titleCtx.shadowBlur = 8;
    titleCtx.shadowColor = '#ff0000';
    titleCtx.fillStyle = '#ff0000';
    titleCtx.fillText('ENEMY', col2, y + 5);
    titleCtx.fillStyle = '#ffffff';
    titleCtx.fillText('50', col3, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('POINTS', col4, y + 5);
    
    // Blockdot
    y += lineHeight;
    drawTitleBlockdot(titleCtx, col1, y, scale);
    titleCtx.shadowColor = '#ff6600';
    titleCtx.fillStyle = '#ff6600';
    titleCtx.fillText('BLOCKDOT', col2, y + 5);
    titleCtx.fillStyle = '#ffffff';
    titleCtx.fillText('200', col3, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('PTS + BOOMBA', col4, y + 5);
    
    // Mini-boss
    y += lineHeight;
    drawTitleMiniBoss(titleCtx, col1, y, scale);
    titleCtx.shadowColor = '#ff0000';
    titleCtx.fillStyle = '#ff0000';
    titleCtx.fillText('MINI-BOSS', col2, y + 5);
    titleCtx.fillStyle = '#ffffff';
    titleCtx.fillText('1000', col3, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.textAlign = 'left';
    titleCtx.fillText('PTS + LOOT', col4, y + 5);
    y += lineHeight * 0.45;
    titleCtx.fillStyle = '#ff6666';
    titleCtx.font = `${11 * scale}px Courier New`;
    titleCtx.fillText('IMMUNE TO BULLETS', col4, y + 5);
    titleCtx.font = `${13 * scale}px Courier New`;
    
    // Harasser (Boss)
    y += lineHeight * 0.8;
    drawTitleHarasser(titleCtx, col1, y, scale);
    titleCtx.shadowColor = '#ff00ff';
    titleCtx.fillStyle = '#ff00ff';
    titleCtx.fillText('HARASSER', col2, y + 5);
    titleCtx.fillStyle = '#ffffff';
    titleCtx.fillText('5000', col3, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('PTS (BOSS)', col4, y + 5);
    y += lineHeight * 0.45;
    titleCtx.fillStyle = '#ff66ff';
    titleCtx.font = `${11 * scale}px Courier New`;
    titleCtx.fillText('IMMUNE TO MISSILES', col4, y + 5);
    titleCtx.font = `${13 * scale}px Courier New`;
    
    // Section: PICKUPS
    y += lineHeight * 0.9;
    titleCtx.textAlign = 'center';
    titleCtx.font = `bold ${16 * scale}px Courier New`;
    titleCtx.shadowBlur = 15;
    titleCtx.shadowColor = '#00ff00';
    titleCtx.fillStyle = '#00ff00';
    titleCtx.fillText('‚Äî PICKUPS ‚Äî', centerX, y);
    
    y += lineHeight * 0.8;
    titleCtx.font = `${13 * scale}px Courier New`;
    titleCtx.textAlign = 'left';
    
    // Shield
    drawTitlePickup(titleCtx, col1, y, 's', '#ffff00', scale);
    titleCtx.shadowColor = '#ffff00';
    titleCtx.fillStyle = '#ffff00';
    titleCtx.fillText('SHIELD', col2, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('RESTORE SHIELD', col3, y + 5);
    
    // Weapon
    y += lineHeight;
    drawTitlePickup(titleCtx, col1, y, 'W', '#00ffff', scale);
    titleCtx.shadowColor = '#00ffff';
    titleCtx.fillStyle = '#00ffff';
    titleCtx.fillText('WEAPON', col2, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('NEW WEAPON', col3, y + 5);
    
    // Missile
    y += lineHeight;
    drawTitlePickup(titleCtx, col1, y, 'M', '#ff6600', scale);
    titleCtx.shadowColor = '#ff6600';
    titleCtx.fillStyle = '#ff6600';
    titleCtx.fillText('MISSILE', col2, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('+2 MISSILES', col3, y + 5);
    
    // Boomba
    y += lineHeight;
    drawTitlePickup(titleCtx, col1, y, 'B', '#ff6600', scale);
    titleCtx.shadowColor = '#ff6600';
    titleCtx.fillStyle = '#ff6600';
    titleCtx.fillText('BOOMBA', col2, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('SCREEN CLEAR', col3, y + 5);
    
    // Heart
    y += lineHeight;
    drawTitleHeart(titleCtx, col1, y, scale);
    titleCtx.shadowColor = '#00ff00';
    titleCtx.fillStyle = '#00ff00';
    titleCtx.fillText('HEART', col2, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('+1 HEALTH', col3, y + 5);
    
    // Extra Life
    y += lineHeight;
    drawTitleShip(titleCtx, col1, y, scale);
    titleCtx.shadowColor = '#00ffff';
    titleCtx.fillStyle = '#00ffff';
    titleCtx.fillText('EXTRA LIFE', col2, y + 5);
    titleCtx.fillStyle = '#888888';
    titleCtx.fillText('+1 LIFE', col3, y + 5);
    
    // Press to start
    y += lineHeight * 1.2;
    titleCtx.textAlign = 'center';
    titleCtx.font = `${18 * scale}px Courier New`;
    const blink = Math.sin(titleTime * 0.08) > 0;
    if (blink) {
        titleCtx.shadowBlur = 20;
        titleCtx.shadowColor = '#00ffff';
        titleCtx.fillStyle = '#00ffff';
        titleCtx.fillText('CLICK TO INITIALIZE SYSTEMS', centerX, y);
    }
    
    // Controls hint
    y += lineHeight * 0.8;
    titleCtx.font = `${10 * scale}px Courier New`;
    titleCtx.shadowBlur = 10;
    titleCtx.shadowColor = '#00aaaa';
    titleCtx.fillStyle = '#00cccc';
    titleCtx.fillText('‚Üê‚Üí/AD Move | Z/SPACE Shoot | V Missile | X Shield | C Boomba', centerX, y);
    
    setTitleAnimationId(requestAnimationFrame(renderTitleScreen));
}
/**
 * Stop the title screen animation
 */
function stopTitleScreen() {
    if (titleAnimationId) {
        cancelAnimationFrame(titleAnimationId);
        setTitleAnimationId(null);
    }
}
// =============================================================================
// Title Screen Sprite Drawing Functions
// =============================================================================
function drawTitleEnemy(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.strokeStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 10;
    ctx.lineWidth = 2;
    ctx.strokeRect(-10, -10, 20, 20);
    ctx.restore();
}
function drawTitleBlockdot(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.strokeStyle = '#ff6600';
    ctx.shadowColor = '#ff6600';
    ctx.shadowBlur = 10;
    ctx.lineWidth = 2;
    ctx.strokeRect(-12, -12, 24, 24);
    ctx.fillStyle = '#ffff00';
    ctx.shadowColor = '#ffff00';
    ctx.beginPath();
    ctx.arc(0, 0, 5, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
}
function drawTitleMiniBoss(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.strokeStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 15;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, -12);
    ctx.lineTo(15, 0);
    ctx.lineTo(0, 12);
    ctx.lineTo(-15, 0);
    ctx.closePath();
    ctx.stroke();
    ctx.strokeStyle = '#ffff00';
    ctx.shadowColor = '#ffff00';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(0, 0, 5, 0, Math.PI * 2);
    ctx.stroke();
    ctx.restore();
}
function drawTitleHarasser(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.strokeStyle = '#ff00ff';
    ctx.shadowColor = '#ff00ff';
    ctx.shadowBlur = 20;
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(0, -15);
    ctx.lineTo(20, 0);
    ctx.lineTo(0, 15);
    ctx.lineTo(-20, 0);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}
function drawTitlePickup(ctx, x, y, letter, color, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale, scale);
    ctx.strokeStyle = color;
    ctx.shadowColor = color;
    ctx.shadowBlur = 10;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.font = 'bold 12px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(letter, 0, 4);
    ctx.restore();
}
function drawTitleHeart(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    const sz = 12 * scale;
    ctx.strokeStyle = '#00ff00';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 15;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(0, sz/4);
    ctx.bezierCurveTo(0, -sz/4, -sz, -sz/4, -sz, sz/4);
    ctx.bezierCurveTo(-sz, sz, 0, sz * 1.2, 0, sz * 1.5);
    ctx.bezierCurveTo(0, sz * 1.2, sz, sz, sz, sz/4);
    ctx.bezierCurveTo(sz, -sz/4, 0, -sz/4, 0, sz/4);
    ctx.stroke();
    ctx.restore();
}
function drawTitleShip(ctx, x, y, scale) {
    ctx.save();
    ctx.translate(x, y);
    ctx.scale(scale * 0.5, scale * 0.5);
    ctx.strokeStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 15;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, -20);
    ctx.lineTo(-25, 10);
    ctx.lineTo(0, 3);
    ctx.lineTo(25, 10);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
}

// ========== js/bullets.js ==========
// APOPHIS - Bullets & Missiles
// Bullet creation, missile logic, and particle effects
// =============================================================================
// Particle Effects
// =============================================================================
/**
 * Create a basic explosion
 */
function createExplosion(x, y) {
    const colors = EXPLOSION_COLORS;
    for (let i = 0; i < 25; i++) {
        particles.push({
            x, y,
            vx: (Math.random() - 0.5) * 20,
            vy: (Math.random() - 0.5) * 20,
            life: 50,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
}
/**
 * Create a damage explosion when player is hit
 */
function createDamageExplosion(x, y) {
    const colors = DAMAGE_EXPLOSION_COLORS;
    for (let i = 0; i < 40; i++) {
        const angle = (Math.PI * 2 * i) / 40;
        const speed = 15 + Math.random() * 10;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 60,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
}
/**
 * Create a spectacular explosion (for mini-boss death)
 */
function createSpectacularExplosion(x, y) {
    const colors = MEGA_EXPLOSION_COLORS.slice(0, 7);
    for (let i = 0; i < 80; i++) {
        const angle = (Math.PI * 2 * i) / 80;
        const speed = 20 + Math.random() * 15;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 80,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 10 + Math.random() * 8;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 70,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
}
/**
 * Create a mega boss explosion
 */
function createMegaBossExplosion(x, y) {
    const colors = MEGA_EXPLOSION_COLORS;
    
    // Massive outer ring
    for (let i = 0; i < 720; i++) {
        const angle = (Math.PI * 2 * i) / 720;
        const speed = 30 + Math.random() * 25;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 120,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    
    // Medium ring
    for (let i = 0; i < 360; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 20 + Math.random() * 15;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 100,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    
    // Inner explosion
    for (let i = 0; i < 240; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 10 + Math.random() * 10;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 130,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    
    // Spiral patterns
    for (let i = 0; i < 180; i++) {
        const angle = (Math.PI * 8 * i) / 180;
        const speed = 22 + (i * 0.4);
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 110,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    
    // Shockwave rings
    for (let ring = 0; ring < 5; ring++) {
        for (let i = 0; i < 120; i++) {
            const angle = (Math.PI * 2 * i) / 120;
            const speed = 25 + ring * 8;
            particles.push({
                x, y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 100 + ring * 10,
                color: colors[ring * 2 % colors.length]
            });
        }
    }
}
/**
 * Create an ultimate explosion (player death)
 */
function createUltimateExplosion(x, y) {
    const colors = MEGA_EXPLOSION_COLORS.slice(0, 9);
    for (let i = 0; i < 240; i++) {
        const angle = (Math.PI * 2 * i) / 240;
        const speed = 25 + Math.random() * 20;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 100,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    for (let i = 0; i < 120; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 15 + Math.random() * 12;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 90,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    for (let i = 0; i < 80; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 8 + Math.random() * 6;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 110,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    for (let i = 0; i < 60; i++) {
        const angle = (Math.PI * 4 * i) / 60;
        const speed = 18 + (i * 0.3);
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 85,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
}
/**
 * Create missile impact explosion
 */
function createMissileExplosion(x, y) {
    const colors = ['#ff6600', '#ff3300', '#ffaa00', '#ff0000', '#ffffff', '#ffff00'];
    for (let i = 0; i < 60; i++) {
        const angle = (Math.PI * 2 * i) / 60;
        const speed = 18 + Math.random() * 12;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 70,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
    for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 8 + Math.random() * 8;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 50,
            color: '#ffffff'
        });
    }
}
/**
 * Create bullet deflection spark
 */
function createDeflectionSpark(x, y) {
    const colors = ['#ffff00', '#ffffff', '#00ffff'];
    for (let i = 0; i < 8; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 4 + Math.random() * 4;
        particles.push({
            x, y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 15,
            color: colors[Math.floor(Math.random() * colors.length)]
        });
    }
}
// =============================================================================
// Weapon Firing
// =============================================================================
/**
 * Fire the current weapon
 */
function fireWeapon() {
    const weapon = weaponInventory[currentWeapon];
    const bulletStartY = shipY - 35;
    
    // Chapters 2 & 3: Angle bullets toward horizon center
    const horizonCenterX = width / 2;
    const horizonCenterY = height * 0.3;
    
    if (chapter === 2 || chapter === 3) {
        const dx = horizonCenterX - shipX;
        const dy = horizonCenterY - bulletStartY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        switch(weapon) {
            case 0: // Default rapid shot
                const speed0 = 12;
                bullets.push({ 
                    x: shipX, 
                    y: bulletStartY, 
                    vx: (dx / distance) * speed0,
                    vy: (dy / distance) * speed0,
                    type: 'vertical', 
                    originX: shipX 
                });
                playSound(800, 'square', 0.1, 0.05);
                break;
            case 1: // Sine wave
                const speed1 = 12;
                bullets.push({ 
                    x: shipX, 
                    y: bulletStartY, 
                    vx: (dx / distance) * speed1,
                    vy: (dy / distance) * speed1,
                    baseVx: (dx / distance) * speed1,
                    type: 'vertical-sine', 
                    phase: time, 
                    originX: shipX 
                });
                playSound(900, 'sine', 0.1, 0.05);
                break;
            case 2: // Scatter shot
                const speed2 = 14;
                for (let i = -2; i <= 2; i++) {
                    const spreadAngle = Math.atan2(dy, dx) + (i * 0.15);
                    bullets.push({ 
                        x: shipX + i * 15, 
                        y: bulletStartY, 
                        vx: Math.cos(spreadAngle) * speed2,
                        vy: Math.sin(spreadAngle) * speed2,
                        type: 'vertical-scatter', 
                        spread: i, 
                        originX: shipX + i * 15 
                    });
                }
                playSound(700, 'square', 0.15, 0.08);
                break;
            case 3: // Laser
                const speed3 = 16;
                bullets.push({ 
                    x: shipX, 
                    y: bulletStartY, 
                    vx: (dx / distance) * speed3,
                    vy: (dy / distance) * speed3,
                    type: 'vertical-laser', 
                    width: 8, 
                    originX: shipX 
                });
                playSound(1200, 'sawtooth', 0.2, 0.1);
                break;
        }
    } else {
        // Chapters 1 & 4: Simple vertical bullets
        switch(weapon) {
            case 0:
                bullets.push({ x: shipX, y: bulletStartY, vy: -12, type: 'vertical', originX: shipX });
                playSound(800, 'square', 0.1, 0.05);
                break;
            case 1:
                bullets.push({ x: shipX, y: bulletStartY, vy: -12, vx: 0, type: 'vertical-sine', phase: time, originX: shipX });
                playSound(900, 'sine', 0.1, 0.05);
                break;
            case 2:
                for (let i = -2; i <= 2; i++) {
                    bullets.push({ x: shipX + i * 15, y: bulletStartY, vy: -14, vx: i * 2, type: 'vertical-scatter', spread: i, originX: shipX + i * 15 });
                }
                playSound(700, 'square', 0.15, 0.08);
                break;
            case 3:
                bullets.push({ x: shipX, y: bulletStartY, vy: -16, type: 'vertical-laser', width: 8, originX: shipX });
                playSound(1200, 'sawtooth', 0.2, 0.1);
                break;
        }
    }
}
/**
 * Update all bullets
 */
function updateBullets() {
    bullets.forEach(b => {
        // Chapters 2 & 3: Continuously home toward horizon center
        if ((chapter === 2 || chapter === 3) && b.vx !== undefined && b.vy !== undefined) {
            const horizonCenterX = width / 2;
            const horizonCenterY = height * 0.3;
            
            const dx = horizonCenterX - b.x;
            const dy = horizonCenterY - b.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            b.distanceToHorizon = distance;
            
            if (distance <= 80) {
                b.reachedHorizon = true;
            }
            
            if (distance > 5) {
                const speed = 12;
                b.vx = (dx / distance) * speed;
                b.vy = (dy / distance) * speed;
            }
        }
        
        // Apply velocity
        if (b.vx !== undefined) b.x += b.vx;
        if (b.vy !== undefined) b.y += b.vy;
        
        // Sine wave movement for chapters 1 & 4
        if ((chapter === 1 || chapter === 4) && b.type === 'vertical-sine') {
            b.x = b.originX + Math.sin((time - b.phase) * 0.2) * 50;
        }
    });
    
    // Cleanup bullets
    if (chapter === 1 || chapter === 4) {
        setBullets(bullets.filter(b => b.y > -50));
    } else {
        setBullets(bullets.filter(b => !b.reachedHorizon));
    }
    
    // Update bounced bullets
    setBullets(bullets.filter(b => {
        if (b.bounced) {
            b.bounceLife--;
            return b.bounceLife > 0 && b.x > 0 && b.x < width && b.y > 0 && b.y < height;
        }
        return true;
    }));
}
// =============================================================================
// Missile System
// =============================================================================
/**
 * Find valid missile target
 */
function findMissileTarget() {
    if (miniBosses.length > 0) {
        let closest = null;
        let closestDist = Infinity;
        miniBosses.forEach(mb => {
            const dist = Math.hypot(mb.x - shipX, mb.y - shipY);
            if (dist < closestDist) {
                closestDist = dist;
                closest = mb;
            }
        });
        return { target: closest, type: 'miniboss' };
    }
    if (harassers.length > 0) {
        return { target: harassers[0], type: 'boss' };
    }
    return null;
}
/**
 * Fire a missile
 */
function fireMissile() {
    if (missileAmmo <= 0 || missileCooldown > 0) return false;
    
    const targetInfo = findMissileTarget();
    if (!targetInfo) return false;
    
    const target = targetInfo.target;
    
    missiles.push({
        x: shipX,
        y: shipY - 20,
        targetType: targetInfo.type,
        target: target,
        startX: shipX,
        startY: shipY - 20,
        progress: 0,
        speed: 0.025,
        trail: []
    });
    
    adjustMissileAmmo(-1);
    setMissileCooldown(MISSILE_COOLDOWN_FRAMES);
    
    playSound(150, 'sawtooth', 0.4, 0.25);
    playSound(80, 'square', 0.3, 0.15);
    
    return true;
}
/**
 * Update all missiles
 */
function updateMissiles() {
    for (let mi = missiles.length - 1; mi >= 0; mi--) {
        const m = missiles[mi];
        
        // Skip bounced missiles - handled separately
        if (m.bounced) continue;
        
        // Check if target still exists
        let targetExists = false;
        let targetX, targetY;
        
        if (m.targetType === 'miniboss') {
            if (miniBosses.includes(m.target)) {
                targetExists = true;
                targetX = m.target.x;
                targetY = m.target.y;
            }
        } else if (m.targetType === 'boss') {
            if (harassers.includes(m.target)) {
                targetExists = true;
                targetX = m.target.x;
                targetY = m.target.y;
            }
        }
        
        if (!targetExists) {
            m.y -= 15;
            if (m.y < -50) missiles.splice(mi, 1);
            continue;
        }
        
        // Store trail
        m.trail.push({ x: m.x, y: m.y });
        if (m.trail.length > 8) m.trail.shift();
        
        // Progress along arc
        m.progress += m.speed;
        
        // Bezier curve for arc
        const arcSide = (m.startX < width / 2) ? 1 : -1;
        const controlX = (m.startX + targetX) / 2 + arcSide * 150;
        const controlY = Math.min(m.startY, targetY) - 100;
        
        const t = Math.min(m.progress, 1);
        const t1 = 1 - t;
        
        m.x = t1 * t1 * m.startX + 2 * t1 * t * controlX + t * t * targetX;
        m.y = t1 * t1 * m.startY + 2 * t1 * t * controlY + t * t * targetY;
        
        // Check for impact
        const dist = Math.hypot(m.x - targetX, m.y - targetY);
        if (dist < 40 || m.progress >= 1) {
            
            if (m.targetType === 'miniboss') {
                // Missiles hit mini-bosses normally
                createMissileExplosion(targetX, targetY);
                playSound(60, 'sawtooth', 0.6, 0.4);
                playSound(120, 'square', 0.4, 0.3);
                
                m.target.hp -= 8;
                if (m.target.hp <= 0) {
                    const mbIndex = miniBosses.indexOf(m.target);
                    if (mbIndex !== -1) {
                        createSpectacularExplosion(m.target.x, m.target.y);
                        // Drop loot
                        if (Math.random() < 0.5) {
                            pickups.push({ x: m.target.x, y: m.target.y, vx: 0, vy: 2, size: 25, type: 'weapon', verticalDrop: true });
                        } else {
                            pickups.push({ x: m.target.x, y: m.target.y, vx: 0, vy: 2, size: 25, type: 'extralife', verticalDrop: true });
                        }
                        pickups.push({ x: m.target.x + 30, y: m.target.y, vx: 0, vy: 2.5, size: 20, type: 'missile', verticalDrop: true });
                        miniBosses.splice(mbIndex, 1);
                        addScore(SCORE_MINIBOSS);
                    }
                }
                missiles.splice(mi, 1);
            } else if (m.targetType === 'boss') {
                // Missiles BOUNCE off the main boss!
                if (!m.bounced) {
                    createDeflectionSpark(m.x, m.y);
                    createDeflectionSpark(m.x + 10, m.y - 5);
                    createDeflectionSpark(m.x - 10, m.y + 5);
                    createDeflectionSpark(m.x, m.y + 10);
                    playSound(1200, 'sine', 0.05, 0.08);
                    playSound(1200, 'sine', 0.08, 0.12);
                    
                    const bounceAngle = Math.PI / 2 + (Math.random() - 0.5) * 1.5;
                    const bounceSpeed = 12;
                    
                    m.bounced = true;
                    m.bounceVx = Math.cos(bounceAngle) * bounceSpeed;
                    m.bounceVy = Math.sin(bounceAngle) * bounceSpeed;
                    m.bounceLife = 120;
                    m.trail = [];
                    
                    m.x = targetX + Math.cos(bounceAngle) * 60;
                    m.y = targetY + Math.sin(bounceAngle) * 60;
                } else {
                    missiles.splice(mi, 1);
                }
            }
        }
    }
    
    // Update bounced missiles
    for (let mi = missiles.length - 1; mi >= 0; mi--) {
        const m = missiles[mi];
        if (m.bounced) {
            m.trail.push({ x: m.x, y: m.y });
            if (m.trail.length > 12) m.trail.shift();
            
            m.x += m.bounceVx;
            m.y += m.bounceVy;
            m.bounceVy += 0.12;
            m.bounceLife--;
            
            if (m.bounceLife <= 0 || m.y > height + 50 || m.x < -50 || m.x > width + 50) {
                createDeflectionSpark(m.x, m.y);
                missiles.splice(mi, 1);
            }
        }
    }
    
    // Cleanup missiles
    setMissiles(missiles.filter(m => m.y > -100 && m.y < height + 100));
}
/**
 * Update particles
 */
function updateParticles() {
    particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life--;
        p.vx *= 0.98;
        p.vy *= 0.98;
    });
    setParticles(particles.filter(p => p.life > 0));
}

// ========== js/pickups.js ==========
// APOPHIS - Pickups
// Pickup spawning, movement, and collection
/**
 * Spawn a shield pickup
 */
function spawnShieldPickup() {
    if (chapter === 1) {
        pickups.push({ 
            x: Math.random() * (width - 200) + 100,
            y: 0,
            vx: 0,
            vy: 3 + Math.random() * 2,
            size: 20 + Math.random() * 15,
            type: 'shield',
            verticalDrop: true
        });
    } else {
        pickups.push({ 
            worldLane: ENEMY_WORLD_LANES[Math.floor(Math.random() * 7)], 
            z: 0, 
            type: 'shield' 
        });
    }
}
/**
 * Spawn a heart (health) pickup
 */
function spawnHeart() {
    if (chapter === 1) {
        hearts.push({ 
            x: Math.random() * (width - 200) + 100,
            y: 0,
            vx: 0,
            vy: 3 + Math.random() * 2,
            size: 15 + Math.random() * 10,
            verticalDrop: true
        });
    } else {
        hearts.push({ 
            worldLane: ENEMY_WORLD_LANES[Math.floor(Math.random() * 7)], 
            z: 0 
        });
    }
}
/**
 * Spawn an invulnerability pickup
 */
function spawnInvulnPickup() {
    if (chapter === 1) {
        pickups.push({ 
            x: Math.random() * (width - 200) + 100,
            y: 0,
            vx: 0,
            vy: 3 + Math.random() * 2,
            size: 20 + Math.random() * 15,
            type: 'invuln',
            verticalDrop: true
        });
    } else {
        pickups.push({ 
            worldLane: ENEMY_WORLD_LANES[Math.floor(Math.random() * 7)], 
            z: 0, 
            type: 'invuln' 
        });
    }
}
/**
 * Spawn a boomba pickup at a specific location (from blockdot)
 */
function spawnBoombaPickup(e) {
    const boombaType = ['area', 'screen', 'charged'][Math.floor(Math.random() * 3)];
    
    if (e.verticalDrop) {
        pickups.push({
            x: e.x,
            y: e.y,
            vx: 0,
            vy: 2,
            size: 25,
            type: 'boomba',
            boombaType: boombaType,
            verticalDrop: true
        });
    } else {
        pickups.push({
            worldLane: e.worldLane,
            z: e.z,
            type: 'boomba',
            boombaType: boombaType
        });
    }
    playSound(400, 'sine', 0.3, 0.15);
}
/**
 * Spawn a missile ammo pickup at a specific location
 */
function spawnMissilePickup(x, y, worldLane, z, isVertical) {
    if (isVertical) {
        pickups.push({
            x: x,
            y: y,
            vx: 0,
            vy: 2.2,
            size: 20,
            type: 'missile',
            verticalDrop: true
        });
    } else {
        pickups.push({
            worldLane: worldLane,
            z: z,
            type: 'missile'
        });
    }
}
/**
 * Update pickup positions
 */
function updatePickups() {
    // Move pickups
    pickups.forEach(p => {
        if (p.verticalDrop) {
            p.y += p.vy;
        } else {
            // Extra life pickups move at half enemy speed
            if (p.type === 'extralife') {
                p.z += (0.005 + (gameSpeed * 0.15)) * 0.5;
            } else {
                p.z += 0.005 + (gameSpeed * 0.1);
            }
        }
    });
    
    // Move hearts
    hearts.forEach(h => {
        if (h.verticalDrop) {
            h.y += h.vy;
        } else {
            h.z += 0.005 + (gameSpeed * 0.1);
        }
    });
}
/**
 * Handle pickup collection
 */
function collectPickups() {
    // Regular pickups
    for (let pi = pickups.length - 1; pi >= 0; pi--) {
        const p = pickups[pi];
        let px, py;
        
        if (p.verticalDrop) {
            px = p.x;
            py = p.y;
        } else {
            px = width/2 + p.worldLane * FOV_SCALE * p.z;
            py = height*0.3 + p.z * height*0.5;
        }
        
        const canCollect = p.verticalDrop ? true : (p.z > 0.8);
        
        if (canCollect && Math.hypot(shipX - px, shipY - py) < 60) {
            collectPickup(p);
            pickups.splice(pi, 1);
        }
    }
    
    // Hearts
    for (let hi = hearts.length - 1; hi >= 0; hi--) {
        const h = hearts[hi];
        let hx, hy;
        
        if (h.verticalDrop) {
            hx = h.x;
            hy = h.y;
        } else {
            hx = width/2 + h.worldLane * FOV_SCALE * h.z;
            hy = height*0.3 + h.z * height*0.5;
        }
        
        const canCollect = h.verticalDrop ? true : (h.z > 0.8);
        
        if (canCollect && Math.hypot(shipX - hx, shipY - hy) < 60) {
            adjustHealth(1);
            playSound(800, 'sine', 0.3, 0.2);
            hearts.splice(hi, 1);
        }
    }
}
/**
 * Apply pickup effect
 */
function collectPickup(p) {
    switch (p.type) {
        case 'shield':
            adjustShieldLevel(20);
            playSound(600, 'sine', 0.3, 0.2);
            break;
            
        case 'weapon':
            const newWeapon = Math.floor(Math.random() * 3) + 1; // 1-3
            addWeapon(newWeapon);
            playSound(600, 'sine', 0.3, 0.2);
            break;
            
        case 'boomba':
            addBoomba(p.boombaType);
            playSound(600, 'sine', 0.3, 0.2);
            break;
            
        case 'invuln':
            setInvulnerabilityTimer(INVULN_PICKUP_DURATION);
            playSound(600, 'sine', 0.3, 0.2);
            break;
            
        case 'extralife':
            adjustLives(1);
            playSound(900, 'sine', 0.5, 0.3);
            break;
            
        case 'missile':
            adjustMissileAmmo(2);
            playSound(550, 'sine', 0.3, 0.2);
            break;
    }
}
/**
 * Cleanup off-screen pickups
 */
function cleanupPickups() {
    setPickups(pickups.filter(p => 
        p.verticalDrop ? p.y < height : p.z < 1.2
    ));
    setHearts(hearts.filter(h => 
        h.verticalDrop ? h.y < height : h.z < 1.2
    ));
}

// ========== js/enemies.js ==========
// APOPHIS - Enemies
// Enemy spawning, movement, and blockdot logic
/**
 * Get the trench offset for winding canyon effect
 */
function getTrenchOffset(zPos) {
    const curveTime = time * 0.02;
    const randomWobble = Math.sin(time * 0.05) * 100 + Math.cos(time * 0.03) * 80;
    return Math.sin(curveTime + (zPos * 3)) * 250 + randomWobble;
}
/**
 * Spawn regular enemy
 */
function spawnEnemy() {
    if (chapter === 1) {
        // Chapter 1: Drop from top of screen
        enemies.push({ 
            x: Math.random() * (width - 200) + 100,
            y: 0,
            vx: 0,
            vy: 4 + Math.random() * 2,
            size: 30 + Math.random() * 30,
            verticalDrop: true
        });
    } else {
        // Chapters 2-3: 3D perspective enemies
        let lane = ENEMY_WORLD_LANES[Math.floor(Math.random() * 7)];
        if (chapter === 3) {
            const offset = getTrenchOffset(0);
            lane = (Math.random() - 0.5) * 350 + offset;
        }
        enemies.push({ worldLane: lane, z: 0, size: 40 });
    }
}
/**
 * Spawn blockdot (boomba carrier)
 */
function spawnBlockdot() {
    if (chapter === 1) {
        // Chapter 1: Drop from top with lateral movement
        enemies.push({ 
            x: Math.random() * (width - 200) + 100,
            y: 0,
            vx: (Math.random() - 0.5) * 4,
            vy: 3 + Math.random() * 2,
            size: 35 + Math.random() * 20,
            verticalDrop: true,
            isBlockdot: true
        });
    } else {
        // Other chapters: 3D perspective
        let lane = ENEMY_WORLD_LANES[Math.floor(Math.random() * 7)];
        if (chapter === 3) {
            const offset = getTrenchOffset(0);
            lane = (Math.random() - 0.5) * 350 + offset;
        }
        enemies.push({ 
            worldLane: lane, 
            z: 0, 
            size: 40,
            lateralSpeed: (Math.random() - 0.5) * 300,
            lateralPhase: Math.random() * Math.PI * 2,
            isBlockdot: true
        });
    }
}
/**
 * Spawn trench walls for canyon chapter
 */
function spawnTrenchWalls() {
    const offset = getTrenchOffset(0);
    // Start wide, narrow progressively
    const widthProgress = Math.min(chapterTimer / 600, 1);
    const trenchWidth = 1800 - (widthProgress * 900);
    trenchBlocks.push({ worldLane: -trenchWidth/2 + offset, z: 0 });
    trenchBlocks.push({ worldLane: trenchWidth/2 + offset, z: 0 });
}
/**
 * Spawn single obstacle block for planetside chapter
 */
function spawnObstacleBlock() {
    const lane = ENEMY_WORLD_LANES[Math.floor(Math.random() * 7)];
    trenchBlocks.push({ 
        worldLane: lane, 
        z: 0, 
        isSingleBlock: true 
    });
}
/**
 * Update all enemies
 */
function updateEnemies() {
    enemies.forEach(e => {
        if (e.verticalDrop) {
            e.y += e.vy;
            e.x += e.vx;
        } else {
            e.z += 0.005 + (gameSpeed * 0.15);
            
            // Blockdots: smooth side-to-side movement
            if (e.isBlockdot) {
                e.lateralPhase += 0.05;
                e.worldLane += Math.sin(e.lateralPhase) * e.lateralSpeed * 0.01;
                e.worldLane = Math.max(-450, Math.min(450, e.worldLane));
            }
        }
    });
}
/**
 * Update trench blocks
 */
function updateTrenchBlocks() {
    trenchBlocks.forEach(b => {
        if (b.isSingleBlock) {
            // Single blocks move at one third enemy speed
            b.z += (0.005 + (gameSpeed * 0.15)) / 3;
        } else {
            // Normal trench walls (Chapter 3)
            b.z += 0.03 + (gameSpeed * 0.2);
        }
    });
}
/**
 * Cleanup off-screen enemies and blocks
 */
function cleanupEnemies() {
    setEnemies(enemies.filter(e => 
        e.verticalDrop ? e.y < height : e.z < 1.2
    ));
    setTrenchBlocks(trenchBlocks.filter(b => b.z < 1.2));
}
/**
 * Check spawn conditions and spawn enemies
 */
function handleSpawning() {
    // Enemy spawning
    if (Math.random() < 0.02 + (gameSpeed * 0.1) + (level * 0.005)) {
        spawnEnemy();
    }
    
    // Blockdot spawning
    if (Math.random() < 0.005 + (level * 0.001)) {
        spawnBlockdot();
    }
    
    // Chapter 3: Trench walls
    if (chapter === 3 && time % 3 === 0) {
        spawnTrenchWalls();
    }
    
    // Chapter 2: Obstacle blocks
    if (chapter === 2 && Math.random() < 0.01) {
        spawnObstacleBlock();
    }
}

// ========== js/bosses.js ==========
// APOPHIS - Bosses
// Mini-boss and Harasser (main boss) logic
import { 
    createExplosion, 
    createSpectacularExplosion, 
    createMegaBossExplosion,
    createDeflectionSpark
} from './bullets.js';
// =============================================================================
// Mini-Boss System
// =============================================================================
/**
 * Spawn a mini-boss
 */
function spawnMiniBoss() {
    const configs = MINIBOSS_CONFIGS;
    const config = configs[Math.min(level - 2, configs.length - 1)];
    
    // Calculate HP: Base 12 at level 2, +3 per level, ¬±20% variance
    const baseHp = 12 + (level - 2) * 3;
    const variance = baseHp * 0.2;
    const actualHp = Math.floor(baseHp + (Math.random() * variance * 2 - variance));
    
    miniBosses.push({
        x: width / 2,
        y: height * 0.25,
        phase: 0,
        hp: actualHp,
        maxHp: actualHp,
        ...config
    });
}
/**
 * Fire a bullet from a mini-boss
 */
function fireMiniBossBullet(mb) {
    const bullet = {
        x: mb.x,
        y: mb.y,
        vy: 5 + gameSpeed * 20,
        type: mb.bulletType
    };
    
    if (mb.bulletType === 'circle') {
        bullet.vy *= 0.7;
    } else if (mb.bulletType === 'triangle') {
        bullet.vy *= 0.6;
    }
    
    miniBossBullets.push(bullet);
    playSound(250, 'sine', 0.08, 0.04);
}
/**
 * Update mini-bosses
 */
function updateMiniBosses() {
    miniBosses.forEach(mb => {
        mb.phase += 0.06;
        if (!mb.targetX || Math.random() < mb.chaosRate) {
            mb.targetX = width * (0.2 + Math.random() * 0.6);
        }
        const dx = mb.targetX - mb.x;
        mb.x += dx * 0.08 + (Math.random() - 0.5) * mb.chaosRate * 50;
        mb.x = Math.max(width * 0.1, Math.min(width * 0.9, mb.x));
        mb.y = height * 0.25 + Math.sin(mb.phase * 2) * 20;
        
        // Firing
        if (time % mb.fireRate === 0) {
            fireMiniBossBullet(mb);
        }
    });
}
/**
 * Update mini-boss bullets
 */
function updateMiniBossBullets() {
    for (let index = miniBossBullets.length - 1; index >= 0; index--) {
        const mbb = miniBossBullets[index];
        mbb.y += mbb.vy;
        
        // Homing triangles
        if (mbb.type === 'triangle' && mbb.y < height) {
            const dx = shipX - mbb.x;
            const dy = shipY - mbb.y;
            const angle = Math.atan2(dy, dx);
            mbb.x += Math.cos(angle) * 1.5;
        }
        
        // Cleanup
        if (mbb.y > height || mbb.y < 0) {
            miniBossBullets.splice(index, 1);
        }
    }
}
/**
 * Handle bullet deflection off mini-bosses
 */
function handleMiniBossDeflection() {
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const bull = bullets[bi];
        if (bull.bounced) continue;
        
        for (let mi = 0; mi < miniBosses.length; mi++) {
            const mb = miniBosses[mi];
            const dist = Math.hypot(bull.x - mb.x, bull.y - mb.y);
            
            if (dist < 35) {
                createDeflectionSpark(bull.x, bull.y);
                playSound(1200, 'sine', 0.05, 0.08);
                
                // Calculate bounce direction
                const dx = bull.x - mb.x;
                const dy = bull.y - mb.y;
                const angle = Math.atan2(dy, dx);
                const bounceAngle = angle + (Math.random() - 0.5) * 0.8;
                const bounceSpeed = 10 + Math.random() * 4;
                
                bull.vx = Math.cos(bounceAngle) * bounceSpeed;
                bull.vy = Math.sin(bounceAngle) * bounceSpeed;
                bull.bounced = true;
                bull.bounceLife = 60;
                bull.type = 'bounced';
                
                // Push bullet outside collision zone
                bull.x = mb.x + Math.cos(bounceAngle) * 40;
                bull.y = mb.y + Math.sin(bounceAngle) * 40;
                
                break;
            }
        }
    }
}
/**
 * Destroy a mini-boss and drop loot
 */
function destroyMiniBoss(mb, index) {
    createSpectacularExplosion(mb.x, mb.y);
    
    // Drop loot
    const dropType = Math.random() < 0.5 ? 'extralife' : 'weapon';
    pickups.push({ 
        x: mb.x,
        y: mb.y,
        vx: 0,
        vy: 2.5,
        size: 25,
        type: dropType,
        verticalDrop: true
    });
    
    // Also drop missile ammo
    pickups.push({ 
        x: mb.x + 30,
        y: mb.y,
        vx: 0,
        vy: 2.5,
        size: 20,
        type: 'missile',
        verticalDrop: true
    });
    
    miniBosses.splice(index, 1);
    addScore(SCORE_MINIBOSS);
}
// =============================================================================
// Main Boss (Harasser) System
// =============================================================================
/**
 * Spawn the Harasser boss
 */
function spawnBoss() {
    harassers.push({ 
        x: width / 2, 
        y: height * 0.2, 
        phase: 0, 
        hp: 40 + level * 15, 
        maxHp: 40 + level * 15 
    });
    setBossActive(true);
}
/**
 * Update the Harasser boss
 */
function updateBoss() {
    harassers.forEach(h => {
        h.phase += 0.04;
        if (!h.targetX || Math.random() < 0.02) {
            h.targetX = width * (0.2 + Math.random() * 0.6);
        }
        const dx = h.targetX - h.x;
        h.x += dx * 0.05 + (Math.random() - 0.5) * 8;
        h.x = Math.max(width * 0.15, Math.min(width * 0.85, h.x));
        h.y = height * 0.2 + Math.sin(h.phase * 2) * 15;
    });
}
/**
 * Handle boss bullet firing pattern
 */
function handleBossFiring() {
    if (bossBulletCooldown > 0) {
        decrementBossBulletCooldown();
    } else if (harassers.length > 0) {
        const h = harassers[0];
        
        // Fire during burst
        if (time % 5 === 0) {
            harasserBullets.push({
                x: h.x + (Math.random() - 0.5) * 120,
                y: h.y,
                vy: 7 + (gameSpeed * 25),
                size: 4
            });
            playSound(200, 'sine', 0.1, 0.03);
            incrementBossBulletBurst();
            
            // Check if burst is complete
            if (bossBulletBurst >= BOSS_BULLET_SEQUENCE[bossBulletPhase]) {
                setBossBulletBurst(0);
                advanceBossBulletPhase();
                
                // Set cooldown between bursts
                if (bossBulletPhase === 0) {
                    setBossBulletCooldown(90);
                } else {
                    setBossBulletCooldown(30);
                }
            }
        }
    }
}
/**
 * Update boss bullets
 */
function updateBossBullets() {
    for (let index = harasserBullets.length - 1; index >= 0; index--) {
        const hb = harasserBullets[index];
        hb.y += hb.vy;
        
        if (hb.y > height || hb.y < 0) {
            harasserBullets.splice(index, 1);
        }
    }
}
/**
 * Destroy the boss
 */
function destroyBoss(h, index) {
    createMegaBossExplosion(h.x, h.y);
    
    // Delayed explosions
    for (let i = 0; i < 15; i++) {
        setTimeout(() => {
            createSpectacularExplosion(
                h.x + (Math.random() - 0.5) * 150, 
                h.y + (Math.random() - 0.5) * 150
            );
        }, i * 50);
    }
    
    harassers.splice(index, 1);
    setHarasserBullets([]);
    setBossActive(false);
    setBossScoreGained(SCORE_BOSS);
    addScore(SCORE_BOSS);
    setBossDefeatedTimer(BOSS_DEFEATED_TIMER);
    playSound(50, 'sawtooth', 1.5, 0.5);
}

// ========== js/player.js ==========
// APOPHIS - Player
// Ship movement, shooting, shield, and boomba systems
// =============================================================================
// Player Movement
// =============================================================================
/**
 * Update player position based on input
 */
function updatePlayerMovement() {
    // Arrow Keys, A/D, and Gamepad
    if (isMovingLeft()) {
        adjustShipAngle(-0.15);
    }
    if (isMovingRight()) {
        adjustShipAngle(0.15);
    }
    
    // Gamepad left stick
    const stickX = getLeftStickX();
    if (stickX) {
        adjustShipAngle(stickX * 0.15);
    }
    
    // Dampen and apply movement
    dampenShipAngle(0.88);
    setShipX(Math.max(80, Math.min(width - 80, shipX + shipAngle * 12)));
}
// =============================================================================
// Shield System
// =============================================================================
/**
 * Update shield state
 */
function updateShield() {
    const wantShield = isShielding() && 
                       shieldLevel > 1 && 
                       !chargingBoomba && 
                       respawnTimer === 0;
    
    setShieldActive(wantShield);
    
    if (shieldActive) {
        adjustShieldLevel(-SHIELD_DRAIN_RATE);
    } else if (shieldLevel < SHIELD_MAX) {
        adjustShieldLevel(SHIELD_REGEN_RATE);
    }
}
// =============================================================================
// Weapon System
// =============================================================================
/**
 * Handle weapon firing
 */
function handleShooting() {
    if (chargingBoomba || respawnTimer > 0) return;
    
    if (isFiring() && time % FIRE_DELAY === 0) {
        fireWeapon();
    }
}
/**
 * Handle weapon cycling input
 */
function handleWeaponCycling() {
    // Keyboard
    if (isWeaponUpPressed()) {
        cycleWeaponNext();
    }
    if (isWeaponDownPressed()) {
        cycleWeaponPrev();
    }
    
    // Gamepad bumpers
    if (isGamepadButtonJustPressed('weaponNext')) {
        cycleWeaponNext();
    }
    if (isGamepadButtonJustPressed('weaponPrev')) {
        cycleWeaponPrev();
    }
}
// =============================================================================
// Missile System
// =============================================================================
/**
 * Handle missile firing
 */
function handleMissileFiring() {
    if (gameOver || respawnTimer > 0) return;
    
    // Keyboard missile key (V)
    if (isMissileKeyPressed() && missileCooldown === 0) {
        fireMissile();
    }
    
    // Gamepad missile button
    if (isGamepadButtonJustPressed('missile')) {
        fireMissile();
    }
    
    // Missile cooldown
    decrementMissileCooldown();
}
// =============================================================================
// Boomba System
// =============================================================================
/**
 * Handle boomba deployment
 */
function handleBoomba() {
    if (respawnTimer > 0) return;
    
    // Start boomba deployment
    if (isBoombaPresseed() && boombaQueue.length > 0 && !chargingBoomba) {
        const nextBoomba = boombaQueue[0];
        
        if (nextBoomba === 'charged') {
            setChargingBoomba(true);
            setBoombaCharge(0);
        } else {
            if (nextBoomba === 'area') {
                launchAreaBoomba();
            } else if (nextBoomba === 'screen') {
                launchScreenBoomba();
            }
            shiftBoomba();
        }
    }
    
    // Handle charged boomba charging
    if (chargingBoomba) {
        if (isBoombaPresseed()) {
            incrementBoombaCharge();
        } else {
            launchChargedBoomba();
            shiftBoomba();
            setChargingBoomba(false);
            setBoombaCharge(0);
        }
    }
}
/**
 * Launch area boomba - clears enemies in radius
 */
function launchAreaBoomba() {
    const radius = AREA_BOOMBA_RADIUS;
    const enemiesToRemove = [];
    
    enemies.forEach((e, idx) => {
        let ex, ey;
        if (e.verticalDrop) {
            ex = e.x;
            ey = e.y;
        } else {
            ex = width/2 + e.worldLane * FOV_SCALE * e.z;
            ey = height*0.3 + e.z * height*0.5;
        }
        
        const dist = Math.hypot(shipX - ex, shipY - ey);
        if (dist < radius) {
            createExplosion(ex, ey);
            enemiesToRemove.push(idx);
            addScore(SCORE_ENEMY);
        }
    });
    
    // Remove in reverse order
    for (let i = enemiesToRemove.length - 1; i >= 0; i--) {
        enemies.splice(enemiesToRemove[i], 1);
    }
    
    // Slow down mini-bosses' fire rate
    miniBosses.forEach(mb => {
        mb.fireRate = Math.min(mb.fireRate + 5, 60);
    });
    
    // Clear nearby mini-boss bullets
    setMiniBossBullets(miniBossBullets.filter(mbb => {
        const dist = Math.hypot(shipX - mbb.x, shipY - mbb.y);
        if (dist < radius) {
            createExplosion(mbb.x, mbb.y);
            return false;
        }
        return true;
    }));
    
    // Clear nearby boss bullets
    setHarasserBullets(harasserBullets.filter(hb => {
        const dist = Math.hypot(shipX - hb.x, shipY - hb.y);
        if (dist < radius) {
            createExplosion(hb.x, hb.y);
            return false;
        }
        return true;
    }));
    
    // Destroy nearby single blocks
    const blocksToRemove = [];
    trenchBlocks.forEach((b, idx) => {
        if (b.isSingleBlock) {
            const bx = width/2 + b.worldLane * FOV_SCALE * b.z;
            const by = height*0.3 + b.z * height*0.5;
            const dist = Math.hypot(shipX - bx, shipY - by);
            if (dist < radius) {
                createExplosion(bx, by);
                blocksToRemove.push(idx);
                addScore(SCORE_OBSTACLE);
            }
        }
    });
    for (let i = blocksToRemove.length - 1; i >= 0; i--) {
        trenchBlocks.splice(blocksToRemove[i], 1);
    }
    
    playSound(120, 'square', 0.6, 0.3);
    
    // Visual feedback - expanding ring
    for (let ring = 0; ring < 5; ring++) {
        for (let i = 0; i < 40; i++) {
            const angle = (Math.PI * 2 * i) / 40;
            const speed = 15 + ring * 5;
            particles.push({
                x: shipX,
                y: shipY,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 60,
                color: '#ff6600'
            });
        }
    }
}
/**
 * Launch screen boomba - clears entire screen
 */
function launchScreenBoomba() {
    // Clear ALL enemies on screen
    enemies.forEach(e => {
        let ex, ey;
        if (e.verticalDrop) {
            ex = e.x;
            ey = e.y;
        } else {
            ex = width/2 + e.worldLane * FOV_SCALE * e.z;
            ey = height*0.3 + e.z * height*0.5;
        }
        createExplosion(ex, ey);
        addScore(SCORE_ENEMY);
    });
    setEnemies([]);
    
    // Clear ALL bullets
    miniBossBullets.forEach(mbb => createExplosion(mbb.x, mbb.y));
    setMiniBossBullets([]);
    harasserBullets.forEach(hb => createExplosion(hb.x, hb.y));
    setHarasserBullets([]);
    
    // Damage mini-bosses heavily
    const miniBossesToRemove = [];
    miniBosses.forEach((mb, idx) => {
        mb.hp -= 15;
        mb.fireRate = Math.min(mb.fireRate + 10, 60);
        createSpectacularExplosion(mb.x, mb.y);
        if (mb.hp <= 0) {
            miniBossesToRemove.push(idx);
            addScore(SCORE_MINIBOSS);
            // Drop loot
            const dropType = Math.random() < 0.5 ? 'extralife' : 'weapon';
            pickups.push({ x: mb.x, y: mb.y, vx: 0, vy: 2.5, size: 25, type: dropType, verticalDrop: true });
            pickups.push({ x: mb.x + 30, y: mb.y, vx: 0, vy: 2.5, size: 20, type: 'missile', verticalDrop: true });
        }
    });
    for (let i = miniBossesToRemove.length - 1; i >= 0; i--) {
        miniBosses.splice(miniBossesToRemove[i], 1);
    }
    
    // Damage main boss
    harassers.forEach(h => {
        h.hp -= 25;
        createMegaBossExplosion(h.x, h.y);
    });
    
    // Destroy ALL single blocks
    const blocksToRemove = [];
    trenchBlocks.forEach((b, idx) => {
        if (b.isSingleBlock) {
            const bx = width/2 + b.worldLane * FOV_SCALE * b.z;
            const by = height*0.3 + b.z * height*0.5;
            createExplosion(bx, by);
            blocksToRemove.push(idx);
            addScore(SCORE_OBSTACLE);
        }
    });
    for (let i = blocksToRemove.length - 1; i >= 0; i--) {
        trenchBlocks.splice(blocksToRemove[i], 1);
    }
    
    playSound(60, 'square', 1.2, 0.4);
    
    // Visual feedback - screen flash
    for (let i = 0; i < 200; i++) {
        particles.push({
            x: Math.random() * width,
            y: Math.random() * height,
            vx: (Math.random() - 0.5) * 20,
            vy: (Math.random() - 0.5) * 20,
            life: 70,
            color: ['#ff6600', '#ff0000', '#ffff00'][Math.floor(Math.random() * 3)]
        });
    }
}
/**
 * Launch charged boomba - power scales with charge time
 */
function launchChargedBoomba() {
    const power = boombaCharge / BOOMBA_CHARGE_MAX;
    
    // Clear enemies based on charge
    const enemiesToRemove = [];
    enemies.forEach((e, idx) => {
        if (Math.random() < power) {
            createExplosion(width/2 + e.worldLane * FOV_SCALE * e.z, height*0.3 + e.z * height*0.5);
            enemiesToRemove.push(idx);
            addScore(SCORE_ENEMY);
        }
    });
    for (let i = enemiesToRemove.length - 1; i >= 0; i--) {
        enemies.splice(enemiesToRemove[i], 1);
    }
    
    // Damage mini-bosses
    const miniBossesToRemove = [];
    miniBosses.forEach((mb, idx) => {
        mb.hp -= Math.floor(power * 10);
        mb.fireRate = Math.min(mb.fireRate + Math.floor(power * 8), 60);
        createExplosion(mb.x, mb.y);
        if (mb.hp <= 0) {
            createSpectacularExplosion(mb.x, mb.y);
            miniBossesToRemove.push(idx);
            addScore(SCORE_MINIBOSS);
            const dropType = Math.random() < 0.5 ? 'extralife' : 'weapon';
            pickups.push({ x: mb.x, y: mb.y, vx: 0, vy: 2.5, size: 25, type: dropType, verticalDrop: true });
            pickups.push({ x: mb.x + 30, y: mb.y, vx: 0, vy: 2.5, size: 20, type: 'missile', verticalDrop: true });
        }
    });
    for (let i = miniBossesToRemove.length - 1; i >= 0; i--) {
        miniBosses.splice(miniBossesToRemove[i], 1);
    }
    
    // Damage main boss
    harassers.forEach(h => {
        h.hp -= Math.floor(power * 20);
        createExplosion(h.x, h.y);
    });
    
    // Destroy blocks based on charge
    const blocksToRemove = [];
    trenchBlocks.forEach((b, idx) => {
        if (b.isSingleBlock && Math.random() < power) {
            const bx = width/2 + b.worldLane * FOV_SCALE * b.z;
            const by = height*0.3 + b.z * height*0.5;
            createExplosion(bx, by);
            blocksToRemove.push(idx);
            addScore(SCORE_OBSTACLE);
        }
    });
    for (let i = blocksToRemove.length - 1; i >= 0; i--) {
        trenchBlocks.splice(blocksToRemove[i], 1);
    }
    
    playSound(80, 'square', 1.0, 0.3);
    
    // Visual feedback
    for (let i = 0; i < 100 * power; i++) {
        particles.push({
            x: width / 2,
            y: height / 2,
            vx: (Math.random() - 0.5) * 30,
            vy: (Math.random() - 0.5) * 30,
            life: 80,
            color: '#ffff00'
        });
    }
}

// ========== js/collision.js ==========
// APOPHIS - Collision Detection
// All collision detection and damage handling
import { 
    createExplosion, 
    createDamageExplosion, 
    createUltimateExplosion,
    createDeflectionSpark
} from './bullets.js';
// =============================================================================
// Bullet vs Enemy Collisions
// =============================================================================
/**
 * Handle bullets hitting enemies
 */
function handleBulletEnemyCollisions() {
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const bull = bullets[bi];
        if (bull.bounced) continue;
        
        // Chapter 2: Bullets bounce off single blocks
        if (chapter === 2) {
            for (const b of trenchBlocks) {
                if (b.isSingleBlock) {
                    const bx = width/2 + b.worldLane * FOV_SCALE * b.z;
                    const by = height*0.3 + b.z * height*0.5;
                    const dist = Math.hypot(bull.x - bx, bull.y - by);
                    const hitRadius = 40 + (b.z * 20);
                    
                    if (dist < hitRadius) {
                        bullets.splice(bi, 1);
                        playSound(800, 'sine', 0.05, 0.06);
                        break;
                    }
                }
            }
        }
        
        // Check enemy hits
        for (let ei = enemies.length - 1; ei >= 0; ei--) {
            const e = enemies[ei];
            let hit = false;
            let ex, ey;
            
            if (e.verticalDrop) {
                ex = e.x;
                ey = e.y;
                const dist = Math.hypot(bull.x - ex, bull.y - ey);
                hit = dist < 50;
            } else {
                ex = width/2 + e.worldLane * FOV_SCALE * e.z;
                ey = height*0.3 + e.z * height*0.5;
                const dist = Math.hypot(bull.x - ex, bull.y - ey);
                const hitRadius = 30 + (e.z * 30);
                hit = dist < hitRadius;
            }
            
            if (hit) {
                playSound(150, 'sawtooth', 0.2, 0.1);
                const explosionX = e.verticalDrop ? e.x : ex;
                const explosionY = e.verticalDrop ? e.y : ey;
                createExplosion(explosionX, explosionY);
                
                // Blockdots drop boombas
                if (e.isBlockdot) {
                    spawnBoombaPickup(e);
                    // 25% chance for missile ammo
                    if (Math.random() < 0.25) {
                        if (e.verticalDrop) {
                            spawnMissilePickup(e.x + 20, e.y, null, null, true);
                        } else {
                            spawnMissilePickup(null, null, e.worldLane + 50, e.z, false);
                        }
                    }
                }
                
                enemies.splice(ei, 1);
                bullets.splice(bi, 1);
                addScore(e.isBlockdot ? SCORE_BLOCKDOT : SCORE_ENEMY);
                break;
            }
        }
    }
}
/**
 * Handle bullets hitting the boss
 */
function handleBulletBossCollisions() {
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const bull = bullets[bi];
        
        for (let hi = harassers.length - 1; hi >= 0; hi--) {
            const h = harassers[hi];
            const dist = Math.hypot(bull.x - h.x, bull.y - h.y);
            
            if (dist < 70) {
                h.hp--;
                bullets.splice(bi, 1);
                createExplosion(h.x, h.y);
                playSound(400, 'square', 0.05, 0.1);
                
                if (h.hp <= 0) {
                    destroyBoss(h, hi);
                }
                break;
            }
        }
    }
}
// =============================================================================
// Player Damage
// =============================================================================
/**
 * Handle player taking damage
 */
function handlePlayerDamage() {
    adjustHealth(-1);
    createDamageExplosion(shipX, shipY);
    playSound(50, 'sawtooth', 0.5, 0.3);
    
    if (health <= 0) {
        adjustLives(-1);
        if (lives > 0) {
            // Respawn
            createUltimateExplosion(shipX, shipY);
            setRespawnTimer(RESPAWN_TIMER_DURATION);
            setHealth(MAX_HEALTH);
            setInvulnerabilityTimer(INVULN_RESPAWN_DURATION);
        } else {
            // Game over
            createUltimateExplosion(shipX, shipY);
            setDeathTimer(DEATH_TIMER_DURATION);
            setGameOver(true);
        }
    }
}
/**
 * Handle boss bullets hitting player
 */
function handleBossBulletPlayerCollisions() {
    for (let index = harasserBullets.length - 1; index >= 0; index--) {
        const hb = harasserBullets[index];
        const dist = Math.hypot(hb.x - shipX, hb.y - shipY);
        
        if (dist < 45 && respawnTimer === 0) {
            if (shieldActive || invulnerabilityTimer > 0) {
                harasserBullets.splice(index, 1);
                addScore(SCORE_DEFLECT_BULLET);
            } else {
                harasserBullets.splice(index, 1);
                handlePlayerDamage();
            }
        }
    }
}
/**
 * Handle mini-boss bullets hitting player
 */
function handleMiniBossBulletPlayerCollisions() {
    for (let index = miniBossBullets.length - 1; index >= 0; index--) {
        const mbb = miniBossBullets[index];
        const dist = Math.hypot(mbb.x - shipX, mbb.y - shipY);
        
        if (dist < 45) {
            if (shieldActive || invulnerabilityTimer > 0) {
                miniBossBullets.splice(index, 1);
                addScore(SCORE_DEFLECT_BULLET);
            } else {
                miniBossBullets.splice(index, 1);
                handlePlayerDamage();
            }
        }
    }
}
/**
 * Handle trench/obstacle collisions
 */
function handleTrenchCollisions() {
    if ((chapter !== 2 && chapter !== 3) || trenchBlocks.length === 0) return;
    
    for (let idx = trenchBlocks.length - 1; idx >= 0; idx--) {
        const b = trenchBlocks[idx];
        const bx = width/2 + b.worldLane * FOV_SCALE * b.z;
        const collisionWidth = b.isSingleBlock ? 50 : 120;
        
        if (b.z > 0.82 && Math.abs(shipX - bx) < collisionWidth) {
            if (invulnerabilityTimer === 0) {
                trenchBlocks.splice(idx, 1);
                playSound(40, 'sawtooth', 0.8, 0.4);
                handlePlayerDamage();
            }
        }
    }
}
/**
 * Handle enemy collision with player
 */
function handleEnemyPlayerCollisions() {
    for (let idx = enemies.length - 1; idx >= 0; idx--) {
        const e = enemies[idx];
        let ex, ey, colliding;
        
        if (e.verticalDrop) {
            ex = e.x;
            ey = e.y;
            colliding = Math.hypot(shipX - ex, shipY - ey) < 60;
        } else {
            ex = width/2 + e.worldLane * FOV_SCALE * e.z;
            ey = height*0.3 + e.z * height*0.5;
            colliding = e.z > 0.85 && Math.hypot(shipX - ex, shipY - ey) < 60;
        }
        
        if (colliding) {
            // Blockdots always drop boombas on collision
            if (e.isBlockdot) {
                spawnBoombaPickup(e);
            }
            
            createExplosion(ex, ey);
            enemies.splice(idx, 1);
            
            if (shieldActive || invulnerabilityTimer > 0) {
                playSound(100, 'sine', 0.1, 0.2);
            } else {
                handlePlayerDamage();
            }
        }
    }
}
/**
 * Handle bullet deflection off mini-bosses
 */
function handleMiniBossDeflection() {
    for (let bi = bullets.length - 1; bi >= 0; bi--) {
        const bull = bullets[bi];
        if (bull.bounced) continue;
        
        for (const mb of miniBosses) {
            const dist = Math.hypot(bull.x - mb.x, bull.y - mb.y);
            
            if (dist < 35) {
                createDeflectionSpark(bull.x, bull.y);
                playSound(1200, 'sine', 0.05, 0.08);
                
                const dx = bull.x - mb.x;
                const dy = bull.y - mb.y;
                const angle = Math.atan2(dy, dx);
                const bounceAngle = angle + (Math.random() - 0.5) * 0.8;
                const bounceSpeed = 10 + Math.random() * 4;
                
                bull.vx = Math.cos(bounceAngle) * bounceSpeed;
                bull.vy = Math.sin(bounceAngle) * bounceSpeed;
                bull.bounced = true;
                bull.bounceLife = 60;
                bull.type = 'bounced';
                
                bull.x = mb.x + Math.cos(bounceAngle) * 40;
                bull.y = mb.y + Math.sin(bounceAngle) * 40;
                
                break;
            }
        }
    }
}
/**
 * Clear bullets near player during respawn
 */
function clearBulletsNearSpawn() {
    setHarasserBullets(
        harasserBullets.filter(hb => 
            Math.hypot(hb.x - shipX, hb.y - shipY) > 200
        )
    );
    setMiniBossBullets(
        miniBossBullets.filter(mbb => 
            Math.hypot(mbb.x - shipX, mbb.y - shipY) > 200
        )
    );
    
    // Clear nearby enemies in chapter 1
    if (chapter === 1) {
        setEnemies(
            enemies.filter(e => 
                Math.hypot(e.x - shipX, e.y - shipY) > 150
            )
        );
    }
}

// ========== js/render.js ==========
// APOPHIS - Rendering
// All drawing code for game elements
// =============================================================================
// Background Rendering
// =============================================================================
/**
 * Render background elements
 */
function renderBackground() {
    const ctx = ctx;
    
    // Clear canvas
    ctx.fillStyle = '#000810';
    ctx.fillRect(0, 0, width, height);
    
    // Grid (chapters 2 & 3 only)
    const showGrid = chapter === 2 || chapter === 3;
    if (showGrid) {
        const gridIntensity = 0.1 + (Math.abs(shipAngle) * 0.2) + (shieldActive ? 0.3 : 0);
        ctx.strokeStyle = `rgba(0, 255, 255, ${gridIntensity})`;
        ctx.shadowBlur = 10 * gridIntensity;
        ctx.shadowColor = '#00ffff';
        for (let i = -1000; i <= 1000; i += 100) {
            ctx.beginPath();
            ctx.moveTo(width/2, height*0.3);
            ctx.lineTo(width/2 + i, height);
            ctx.stroke();
        }
    }
    
    // Stars
    if (chapter === 3) {
        // Warp speed effect
        const horizonX = width / 2;
        const horizonY = height * 0.3;
        
        stars.forEach(s => {
            const dx = s.x - horizonX;
            const dy = s.y - horizonY;
            const angle = Math.atan2(dy, dx);
            const speed = s.speed * 200;
            s.x += Math.cos(angle) * speed;
            s.y += Math.sin(angle) * speed;
            
            if (s.x < 0 || s.x > width || s.y < 0 || s.y > height) {
                s.x = horizonX + (Math.random() - 0.5) * 50;
                s.y = horizonY + (Math.random() - 0.5) * 50;
            }
            
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.fillRect(s.x, s.y, s.z * 3, s.z * 3);
        });
    } else {
        // Normal star movement
        const starSpeedMultiplier = chapter === 4 ? 400 : 15;
        stars.forEach(s => {
            ctx.fillStyle = '#fff';
            ctx.shadowBlur = 0;
            ctx.fillRect(s.x, s.y, s.z * 3, s.z * 3);
            s.y = (s.y + s.speed * starSpeedMultiplier) % height;
        });
    }
}
// =============================================================================
// Entity Rendering
// =============================================================================
/**
 * Render mini-bosses
 */
function renderMiniBosses() {
    const ctx = ctx;
    
    miniBosses.forEach(mb => {
        ctx.strokeStyle = mb.color1;
        ctx.shadowColor = mb.color1;
        ctx.shadowBlur = 15;
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(mb.x, mb.y - 15);
        ctx.lineTo(mb.x + 20, mb.y);
        ctx.lineTo(mb.x, mb.y + 15);
        ctx.lineTo(mb.x - 20, mb.y);
        ctx.closePath();
        ctx.stroke();
        
        // Secondary color accent
        ctx.strokeStyle = mb.color2;
        ctx.shadowColor = mb.color2;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(mb.x, mb.y, 8, 0, Math.PI * 2);
        ctx.stroke();
        
        // Health bar
        const barW = 80;
        ctx.fillStyle = '#440044';
        ctx.fillRect(mb.x - barW/2, mb.y - 30, barW, 4);
        ctx.fillStyle = mb.color1;
        ctx.fillRect(mb.x - barW/2, mb.y - 30, barW * (mb.hp / mb.maxHp), 4);
    });
}
/**
 * Render mini-boss bullets
 */
function renderMiniBossBullets() {
    const ctx = ctx;
    
    miniBossBullets.forEach(mbb => {
        ctx.shadowBlur = 12;
        if (mbb.type === 'line') {
            ctx.fillStyle = '#ff0000';
            ctx.shadowColor = '#ff0000';
            ctx.fillRect(mbb.x - 2, mbb.y, 4, 12);
        } else if (mbb.type === 'circle') {
            ctx.fillStyle = '#ff6600';
            ctx.shadowColor = '#ff6600';
            ctx.beginPath();
            ctx.arc(mbb.x, mbb.y, 5, 0, Math.PI * 2);
            ctx.fill();
        } else if (mbb.type === 'triangle') {
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.beginPath();
            ctx.moveTo(mbb.x, mbb.y - 6);
            ctx.lineTo(mbb.x + 5, mbb.y + 6);
            ctx.lineTo(mbb.x - 5, mbb.y + 6);
            ctx.closePath();
            ctx.fill();
        }
    });
}
/**
 * Render missiles
 */
function renderMissiles() {
    const ctx = ctx;
    
    missiles.forEach(m => {
        let angle = -Math.PI / 2;
        
        if (m.bounced) {
            angle = Math.atan2(m.bounceVy, m.bounceVx) + time * 0.5;
        } else if (m.trail.length > 0) {
            const lastTrail = m.trail[m.trail.length - 1];
            angle = Math.atan2(m.y - lastTrail.y, m.x - lastTrail.x);
        }
        
        // Draw trail
        ctx.shadowBlur = 8;
        m.trail.forEach((t, i) => {
            const alpha = (i + 1) / m.trail.length * 0.6;
            const size = 3 + (i / m.trail.length) * 4;
            ctx.fillStyle = `rgba(255, 100, 0, ${alpha})`;
            ctx.shadowColor = '#ff6600';
            ctx.beginPath();
            ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
            ctx.fill();
        });
        
        // Draw missile body
        ctx.fillStyle = '#ff3300';
        ctx.shadowColor = '#ff6600';
        ctx.shadowBlur = 20;
        
        ctx.save();
        ctx.translate(m.x, m.y);
        ctx.rotate(angle + Math.PI / 2);
        
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(-6, 8);
        ctx.lineTo(0, 4);
        ctx.lineTo(6, 8);
        ctx.closePath();
        ctx.fill();
        
        // Engine glow
        ctx.fillStyle = '#ffff00';
        ctx.shadowColor = '#ffff00';
        ctx.beginPath();
        ctx.arc(0, 6, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
    });
}
/**
 * Render the Harasser boss
 */
function renderBoss() {
    const ctx = ctx;
    
    harassers.forEach(h => {
        ctx.strokeStyle = '#ff00ff';
        ctx.shadowColor = '#ff00ff';
        ctx.shadowBlur = 20;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(h.x, h.y - 20);
        ctx.lineTo(h.x + 30, h.y);
        ctx.lineTo(h.x, h.y + 20);
        ctx.lineTo(h.x - 30, h.y);
        ctx.closePath();
        ctx.stroke();
        
        // Health bar
        const barW = 120;
        ctx.fillStyle = '#440044';
        ctx.fillRect(h.x - barW/2, h.y - 45, barW, 6);
        ctx.fillStyle = '#ff00ff';
        ctx.fillRect(h.x - barW/2, h.y - 45, barW * (h.hp / h.maxHp), 6);
    });
}
/**
 * Render boss bullets
 */
function renderBossBullets() {
    const ctx = ctx;
    
    harasserBullets.forEach(hb => {
        ctx.fillStyle = '#ff00ff';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#ff00ff';
        ctx.fillRect(hb.x - 2, hb.y, 4, 15);
    });
}
/**
 * Render trench walls and obstacles
 */
function renderTrenchBlocks() {
    const ctx = ctx;
    
    trenchBlocks.forEach(b => {
        const bx = width/2 + b.worldLane * FOV_SCALE * b.z;
        const by = height*0.3 + b.z * height*0.5;
        
        if (b.isSingleBlock) {
            const sz = 90 * b.z;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + Math.random()*0.3})`;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(bx, by - sz);
            ctx.lineTo(bx + sz/1.5, by);
            ctx.lineTo(bx - sz/1.5, by);
            ctx.closePath();
            ctx.fill();
        } else {
            const sz = 180 * b.z;
            ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + Math.random()*0.3})`;
            ctx.shadowBlur = 15;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(bx, by - sz);
            ctx.lineTo(bx + sz/1.5, by);
            ctx.lineTo(bx - sz/1.5, by);
            ctx.closePath();
            ctx.fill();
        }
    });
}
/**
 * Render player bullets
 */
function renderBullets() {
    const ctx = ctx;
    
    bullets.forEach(b => {
        const bY = b.y;
        let bSize = 4;
        let bLength = 35;
        
        // Scale bullets in chapters 2 & 3
        if ((chapter === 2 || chapter === 3) && b.distanceToHorizon !== undefined) {
            const maxDistance = 400;
            const normalizedDistance = Math.min(b.distanceToHorizon / maxDistance, 1);
            const scale = 0.2 + (normalizedDistance * 0.8);
            bSize *= scale;
            bLength *= scale;
        }
        
        ctx.shadowBlur = 15;
        
        if (b.type === 'bounced') {
            const alpha = b.bounceLife / 60;
            ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 10 * alpha;
            ctx.save();
            ctx.translate(b.x, b.y);
            ctx.rotate(time * 0.3);
            ctx.fillRect(-3, -3, 6, 6);
            ctx.restore();
        } else if (b.type === 'vertical-laser') {
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.fillRect(b.x - (b.width || 4) * (bSize/4), bY, (b.width || 4) * (bSize/2), 40 * (bLength/35));
        } else if (b.type === 'vertical-scatter') {
            ctx.fillStyle = '#ff00ff';
            ctx.shadowColor = '#ff00ff';
            ctx.fillRect(b.x - bSize, bY, bSize * 2, 25 * (bLength/35));
        } else if (b.type === 'vertical-sine') {
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.fillRect(b.x - bSize/2, bY, bSize, 30 * (bLength/35));
        } else {
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.fillRect(b.x - bSize/2, bY, bSize, bLength);
        }
    });
}
/**
 * Render pickups
 */
function renderPickups() {
    const ctx = ctx;
    
    pickups.forEach(p => {
        let sz, px, py;
        
        if (p.verticalDrop) {
            sz = p.size || 25;
            px = p.x;
            py = p.y;
        } else {
            sz = 25 * p.z;
            px = width/2 + p.worldLane * FOV_SCALE * p.z;
            py = height*0.3 + p.z * height*0.5;
        }
        
        ctx.shadowBlur = 15;
        ctx.font = '12px Courier New';
        ctx.textAlign = 'center';
        
        if (p.type === 'weapon') {
            ctx.strokeStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(px, py, sz, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillText('W', px, py + 4);
        } else if (p.type === 'boomba') {
            ctx.strokeStyle = '#ff6600';
            ctx.shadowColor = '#ff6600';
            ctx.fillStyle = '#ff6600';
            ctx.beginPath();
            ctx.arc(px, py, sz, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillText('B', px, py + 4);
        } else if (p.type === 'invuln') {
            ctx.strokeStyle = '#ffffff';
            ctx.shadowColor = '#ffffff';
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(px, py, sz, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillText('I', px, py + 4);
        } else if (p.type === 'extralife') {
            ctx.strokeStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.fillStyle = '#00ffff';
            ctx.beginPath();
            ctx.arc(px, py, sz, 0, Math.PI * 2);
            ctx.stroke();
            
            // Draw tiny ship inside
            ctx.save();
            ctx.translate(px, py);
            const scale = sz / 80;
            ctx.scale(scale, scale);
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, -25);
            ctx.lineTo(-30, 10);
            ctx.lineTo(0, 5);
            ctx.lineTo(30, 10);
            ctx.closePath();
            ctx.stroke();
            ctx.restore();
        } else if (p.type === 'shield') {
            ctx.strokeStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.fillStyle = '#ffff00';
            ctx.beginPath();
            ctx.arc(px, py, sz, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillText('s', px, py + 4);
        } else if (p.type === 'missile') {
            ctx.strokeStyle = '#ff3300';
            ctx.shadowColor = '#ff6600';
            ctx.fillStyle = '#ff3300';
            ctx.beginPath();
            ctx.arc(px, py, sz, 0, Math.PI * 2);
            ctx.stroke();
            ctx.fillText('M', px, py + 4);
        }
    });
}
/**
 * Render hearts
 */
function renderHearts() {
    const ctx = ctx;
    
    hearts.forEach(h => {
        let sz, hx, hy;
        
        if (h.verticalDrop) {
            sz = h.size || 20;
            hx = h.x;
            hy = h.y;
        } else {
            sz = 20 * h.z;
            hx = width/2 + h.worldLane * FOV_SCALE * h.z;
            hy = height*0.3 + h.z * height*0.5;
        }
        
        ctx.strokeStyle = '#00ff00';
        ctx.shadowColor = '#00ff00';
        ctx.shadowBlur = 15;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(hx, hy + sz/4);
        ctx.bezierCurveTo(hx, hy - sz/4, hx - sz, hy - sz/4, hx - sz, hy + sz/4);
        ctx.bezierCurveTo(hx - sz, hy + sz, hx, hy + sz * 1.2, hx, hy + sz * 1.5);
        ctx.bezierCurveTo(hx, hy + sz * 1.2, hx + sz, hy + sz, hx + sz, hy + sz/4);
        ctx.bezierCurveTo(hx + sz, hy - sz/4, hx, hy - sz/4, hx, hy + sz/4);
        ctx.stroke();
    });
}
/**
 * Render enemies
 */
function renderEnemies() {
    const ctx = ctx;
    
    enemies.forEach(e => {
        let sz, ex, ey;
        
        if (e.verticalDrop) {
            sz = e.size;
            ex = e.x;
            ey = e.y;
        } else {
            sz = e.size * e.z;
            ex = width/2 + e.worldLane * FOV_SCALE * e.z;
            ey = height*0.3 + e.z * height*0.5;
        }
        
        if (e.isBlockdot) {
            ctx.strokeStyle = '#ff6600';
            ctx.shadowColor = '#ff6600';
            ctx.lineWidth = 2;
            ctx.strokeRect(ex - sz, ey - sz, sz * 2, sz * 2);
            
            ctx.fillStyle = '#ffff00';
            ctx.shadowColor = '#ffff00';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(ex, ey, sz * 0.3, 0, Math.PI * 2);
            ctx.fill();
        } else {
            ctx.strokeStyle = '#ff3333';
            ctx.shadowColor = '#ff0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(ex - sz, ey - sz, sz * 2, sz * 2);
        }
    });
}
/**
 * Render particles
 */
function renderParticles() {
    const ctx = ctx;
    ctx.shadowBlur = 0;
    
    particles.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.globalAlpha = p.life / 60;
        ctx.fillRect(p.x, p.y, 3, 3);
    });
    ctx.globalAlpha = 1;
}
/**
 * Render player ship
 */
function renderPlayer() {
    const ctx = ctx;
    
    if (gameOver || respawnTimer > 0) return;
    
    ctx.save();
    ctx.translate(shipX, shipY);
    ctx.rotate(shipAngle * 0.2);
    
    // Invulnerability effect
    if (invulnerabilityTimer > 0) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3 + Math.sin(time * 0.5) * 0.3;
        ctx.beginPath();
        ctx.arc(0, 0, 85, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    
    // Shield effect
    if (shieldActive) {
        ctx.strokeStyle = '#ffff00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, 75 + Math.sin(time * 0.5) * 5, 0, Math.PI * 2);
        ctx.stroke();
    }
    
    // Charging boomba effect
    if (chargingBoomba) {
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 3;
        ctx.globalAlpha = 0.5 + (boombaCharge / 300) * 0.5;
        ctx.beginPath();
        ctx.arc(0, 0, 60 + (boombaCharge / 300) * 40, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = 1;
    }
    
    // Ship body
    ctx.strokeStyle = '#00ffff';
    ctx.lineWidth = 3;
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.moveTo(0, -35);
    ctx.lineTo(-45, 15);
    ctx.lineTo(0, 5);
    ctx.lineTo(45, 15);
    ctx.closePath();
    ctx.stroke();
    ctx.restore();
    
    // Missile lock-on indicator
    if (missileAmmo > 0 && missileCooldown === 0) {
        const targetInfo = findMissileTarget();
        if (targetInfo) {
            const target = targetInfo.target;
            ctx.strokeStyle = '#ff3300';
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 15;
            ctx.lineWidth = 2;
            
            const pulseSize = 25 + Math.sin(time * 0.2) * 5;
            
            ctx.beginPath();
            ctx.moveTo(target.x - pulseSize, target.y - pulseSize + 10);
            ctx.lineTo(target.x - pulseSize, target.y - pulseSize);
            ctx.lineTo(target.x - pulseSize + 10, target.y - pulseSize);
            ctx.moveTo(target.x + pulseSize - 10, target.y - pulseSize);
            ctx.lineTo(target.x + pulseSize, target.y - pulseSize);
            ctx.lineTo(target.x + pulseSize, target.y - pulseSize + 10);
            ctx.moveTo(target.x + pulseSize, target.y + pulseSize - 10);
            ctx.lineTo(target.x + pulseSize, target.y + pulseSize);
            ctx.lineTo(target.x + pulseSize - 10, target.y + pulseSize);
            ctx.moveTo(target.x - pulseSize + 10, target.y + pulseSize);
            ctx.lineTo(target.x - pulseSize, target.y + pulseSize);
            ctx.lineTo(target.x - pulseSize, target.y + pulseSize - 10);
            ctx.stroke();
            
            ctx.fillStyle = '#ff3300';
            ctx.font = 'bold 10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('LOCK', target.x, target.y + pulseSize + 12);
        }
    }
}
/**
 * Render shield and health bars
 */
function renderBars() {
    const ctx = ctx;
    
    // Shield bar
    ctx.strokeStyle = '#333';
    ctx.strokeRect(width - 40, height * 0.3, 15, height * 0.4);
    ctx.fillStyle = '#ffff00';
    ctx.fillRect(width - 40, height * 0.7, 15, -(height * 0.4 * (shieldLevel / 100)));
    
    // Health bar
    const healthBarX = width - 70;
    ctx.strokeStyle = '#333';
    ctx.strokeRect(healthBarX, height * 0.3, 15, height * 0.4);
    ctx.fillStyle = '#00ff00';
    ctx.fillRect(healthBarX, height * 0.7, 15, -(height * 0.4 * (health / MAX_HEALTH)));
}

// ========== js/hud.js ==========
// APOPHIS - HUD & Overlays
// HUD rendering and overlay screens (game over, transitions)
/**
 * Render the complete HUD
 */
function renderHUD() {
    const ctx = ctx;
    ctx.shadowBlur = 0;
    ctx.font = '14px Courier New';
    ctx.textAlign = 'left';
    
    // Weapon display
    const weaponName = WEAPON_NAMES[weaponInventory[currentWeapon]] || 'DEFAULT';
    ctx.fillStyle = '#00ffff';
    ctx.fillText(`WEAPON: ${weaponName}`, 20, height - 100);
    
    // Missiles
    ctx.fillStyle = missileAmmo <= 2 ? '#ff3300' : '#ff6600';
    ctx.fillText(`MISSILES: ${missileAmmo}/${MAX_MISSILE_AMMO}`, 20, height - 80);
    
    // Boombas
    ctx.fillStyle = '#ff6600';
    ctx.fillText(`BOOMBAS: ${boombaQueue.length}/${MAX_BOOMBA_QUEUE}`, 20, height - 60);
    
    if (boombaQueue.length > 0) {
        const display = boombaQueue.slice(0, 3).map((b, idx) => {
            const labels = { area: 'AREA', screen: 'SCREEN', charged: 'CHARGED' };
            return idx === 0 ? `[${labels[b]}]` : labels[b];
        }).join(' ‚Üí ');
        ctx.fillStyle = '#ffaa66';
        ctx.fillText(display, 20, height - 40);
    }
    
    // Invulnerability
    if (invulnerabilityTimer > 0) {
        ctx.fillStyle = '#ffffff';
        ctx.fillText(`INVULN: ${Math.ceil(invulnerabilityTimer / 60)}s`, 20, height - 20);
    }
    
    // Right side icons
    renderSideIcons();
}
/**
 * Render the side icons (lives, weapons, boombas)
 */
function renderSideIcons() {
    const ctx = ctx;
    const healthBarX = width - 70;
    const iconAreaRightEdge = healthBarX - 30;
    
    // Lives indicator - tiny ship icons stacked vertically
    ctx.shadowBlur = 0;
    const shipIconSize = 0.4;
    const verticalSpacing = 20;
    const lifeIconsX = iconAreaRightEdge - 20;
    const lifeIconsStartY = height * 0.35;
    
    for (let i = 0; i < lives; i++) {
        const x = lifeIconsX;
        const y = lifeIconsStartY + i * verticalSpacing;
        
        ctx.save();
        ctx.translate(x, y);
        ctx.scale(shipIconSize, shipIconSize);
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 3;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(0, -35);
        ctx.lineTo(-45, 15);
        ctx.lineTo(0, 5);
        ctx.lineTo(45, 15);
        ctx.closePath();
        ctx.stroke();
        ctx.restore();
    }
    
    // Upgrade icons
    let upgradeX = lifeIconsX;
    let upgradeY = lifeIconsStartY + (lives * verticalSpacing) + 15;
    const iconSize = 10;
    const iconSpacing = 18;
    
    ctx.shadowBlur = 0;
    ctx.lineWidth = 2;
    
    // Weapon icons
    for (let idx = 0; idx < weaponInventory.length; idx++) {
        const weaponId = weaponInventory[idx];
        const isActive = idx === currentWeapon;
        ctx.fillStyle = isActive ? '#00ffff' : '#004444';
        ctx.strokeStyle = isActive ? '#00ffff' : '#004444';
        
        ctx.beginPath();
        ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(WEAPON_ICONS[weaponId], upgradeX, upgradeY);
        
        upgradeY += iconSpacing;
    }
    
    // Boomba queue icons
    upgradeY += 5;
    const slotsToShow = Math.min(5, Math.max(3, boombaQueue.length));
    
    for (let i = 0; i < slotsToShow; i++) {
        const hasBoomba = i < boombaQueue.length;
        const boomba = hasBoomba ? boombaQueue[i] : null;
        const isNext = i === 0 && hasBoomba;
        const isCharging = isNext && chargingBoomba;
        
        if (hasBoomba) {
            let letter, baseColor;
            if (boomba === 'area') {
                letter = 'A';
                baseColor = '#ff6600';
            } else if (boomba === 'screen') {
                letter = 'S';
                baseColor = '#ff0000';
            } else {
                letter = 'C';
                baseColor = '#ff6600';
            }
            
            const color = isCharging ? '#ffff00' : (isNext ? '#ffaa66' : baseColor);
            const alpha = isNext ? 1 : 0.5;
            
            ctx.globalAlpha = alpha;
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = isNext ? 3 : 2;
            
            ctx.beginPath();
            ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.font = 'bold 12px Courier New';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter, upgradeX, upgradeY);
            
            ctx.globalAlpha = 1;
        } else {
            ctx.globalAlpha = 0.2;
            ctx.strokeStyle = '#666666';
            ctx.lineWidth = 1;
            
            ctx.beginPath();
            ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
            ctx.stroke();
            
            ctx.globalAlpha = 1;
        }
        
        upgradeY += iconSpacing;
    }
    
    // "+X more" indicator
    if (boombaQueue.length > 5) {
        ctx.fillStyle = '#ff6600';
        ctx.globalAlpha = 0.7;
        ctx.font = 'bold 10px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(`+${boombaQueue.length - 5}`, upgradeX, upgradeY);
        ctx.globalAlpha = 1;
    }
    
    // Invulnerability icon
    if (invulnerabilityTimer > 0) {
        upgradeY += 5;
        const pulseAlpha = 0.5 + Math.sin(time * 0.3) * 0.5;
        ctx.globalAlpha = pulseAlpha;
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
        ctx.stroke();
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('I', upgradeX, upgradeY);
        ctx.globalAlpha = 1;
    }
}
/**
 * Render game over screen
 */
function renderGameOver() {
    if (!gameOver || deathTimer > 0) return;
    
    const ctx = ctx;
    
    ctx.fillStyle = 'rgba(0,0,0,0.9)';
    ctx.fillRect(0, 0, width, height);
    ctx.textAlign = 'center';
    
    // GAME OVER
    ctx.font = 'bold 64px Courier New';
    ctx.shadowBlur = 40;
    ctx.shadowColor = '#ff0000';
    ctx.fillStyle = '#ff0000';
    ctx.fillText('GAME OVER', width/2, height/2 - 140);
    
    // APOPHIS STEERING COMMITTEE
    ctx.font = '16px Courier New';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#ff00ff';
    ctx.fillStyle = '#ff00ff';
    ctx.fillText('APOPHIS STEERING COMMITTEE-27', width/2, height/2 - 90);
    
    // EARTH DEFENSE FAILURE
    ctx.font = 'bold 20px Courier New';
    ctx.shadowBlur = 15;
    ctx.shadowColor = '#ffff00';
    ctx.fillStyle = '#ffff00';
    ctx.fillText('EARTH DEFENSE FAILURE ‚Äî APOPHIS ADVANCES', width/2, height/2 - 40);
    
    // FINAL SCORE label
    ctx.font = '18px Courier New';
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#888888';
    ctx.fillStyle = '#888888';
    ctx.fillText('FINAL SCORE', width/2, height/2 + 20);
    
    // Score with color cycling glow
    const hue = (time * 2) % 360;
    ctx.font = 'bold 56px Courier New';
    ctx.shadowBlur = 35;
    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
    ctx.fillStyle = '#00ffff';
    ctx.fillText(`${score} PTS`, width/2, height/2 + 80);
    
    // PRESS -R- TO RESTART
    const blink = Math.sin(time * 0.08) > 0;
    if (blink) {
        ctx.font = '20px Courier New';
        ctx.shadowBlur = 15;
        ctx.shadowColor = '#00ffff';
        ctx.fillStyle = '#00ffff';
        ctx.fillText('PRESS -R- TO RESTART', width/2, height/2 + 150);
    }
    ctx.shadowBlur = 0;
}
/**
 * Render level transition screen
 */
function renderLevelTransition() {
    if (levelTransitionTimer <= 0) return;
    
    const ctx = ctx;
    
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = '#00ff00';
    ctx.shadowBlur = 30;
    ctx.shadowColor = '#00ff00';
    ctx.font = 'bold 48px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`LEVEL ${level - 1} COMPLETE`, width/2, height/2 - 100);
    
    ctx.font = 'bold 32px Courier New';
    ctx.fillStyle = '#ffff00';
    ctx.shadowColor = '#ffff00';
    ctx.fillText(`BOSS DEFEATED: +${bossScoreGained} POINTS`, width/2, height/2 - 40);
    
    // Score with color cycling
    const hue = (time * 2) % 360;
    ctx.font = 'bold 36px Courier New';
    ctx.shadowBlur = 25;
    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
    ctx.fillStyle = '#00ffff';
    ctx.fillText(`YOU'VE AMASSED ${score} PTS`, width/2, height/2 + 30);
    
    ctx.font = 'bold 36px Courier New';
    ctx.fillStyle = '#00ffff';
    ctx.shadowColor = '#00ffff';
    ctx.shadowBlur = 30;
    ctx.fillText(`ENTERING LEVEL ${level}`, width/2, height/2 + 100);
    ctx.shadowBlur = 0;
}
/**
 * Render boss defeated celebration
 */
function renderBossDefeated() {
    if (bossDefeatedTimer <= 0) return;
    
    const ctx = ctx;
    ctx.fillStyle = 'rgba(0,0,0,0.1)';
    ctx.fillRect(0, 0, width, height);
}
/**
 * Render chapter transition screen
 */
function renderChapterTransition() {
    if (chapterTransitionTimer <= 0) return;
    
    const ctx = ctx;
    
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, width, height);
    ctx.fillStyle = '#ffff00';
    ctx.shadowBlur = 25;
    ctx.shadowColor = '#ffff00';
    ctx.font = 'bold 40px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`CHAPTER ${chapter}: ${CHAPTER_NAMES[chapter - 1]}`, width/2, height/2 - 30);
    
    // Score with color cycling
    const hue = (time * 2) % 360;
    ctx.font = 'bold 28px Courier New';
    ctx.shadowBlur = 20;
    ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
    ctx.fillStyle = '#00ffff';
    ctx.fillText(`YOU'VE AMASSED ${score} PTS`, width/2, height/2 + 30);
    ctx.shadowBlur = 0;
}
/**
 * Update sector display in DOM
 */
function updateSectorDisplay() {
    if (sectorEl) {
        sectorEl.innerText = `LEVEL ${level} - ${CHAPTER_NAMES[chapter - 1]}`;
    }
}

// ========== js/main.js ==========
// APOPHIS - Main
// Game loop, initialization, and ties everything together
import { 
    handleBulletEnemyCollisions, 
    handleBulletBossCollisions, 
    handleBossBulletPlayerCollisions,
    handleMiniBossBulletPlayerCollisions,
    handleTrenchCollisions,
    handleEnemyPlayerCollisions,
    handleMiniBossDeflection,
    clearBulletsNearSpawn
} from './collision.js';
// =============================================================================
// Initialization
// =============================================================================
/**
 * Initialize the game
 */
function init() {
    resetGameState();
    resize();
    
    // Create stars
    const stars = Array.from({length: 150}, () => ({
        x: Math.random() * width,
        y: Math.random() * height,
        z: Math.random(),
        speed: Math.random() * 0.02 + 0.005
    }));
    setStars(stars);
    
    updateSectorDisplay();
}
/**
 * Handle window resize
 */
function resize() {
    const canvas = canvas;
    setDimensions(window.innerWidth, window.innerHeight);
    canvas.width = width;
    canvas.height = height;
    setShipPosition(width / 2, height * 0.8);
}
/**
 * Get chapter duration
 */
function getChapterDuration() {
    if (chapter <= 3) {
        return CHAPTER_DURATION;
    }
    return Infinity;
}
/**
 * Advance to next chapter
 */
function advanceChapter() {
    setChapterTimer(0);
    incrementChapter();
    
    if (chapter > 4) {
        // Level complete
        incrementLevel();
        setChapter(1);
        setEnemies([]);
        setTrenchBlocks([]);
        setPickups([]);
        setHearts([]);
        setMiniBosses([]);
        setMiniBossBullets([]);
        setMissiles([]);
    } else {
        // Chapter transition
        setChapterTransitionTimer(CHAPTER_TRANSITION_TIMER);
        setEnemies([]);
        setTrenchBlocks([]);
        setPickups([]);
        setHearts([]);
    }
    
    updateSectorDisplay();
}
// =============================================================================
// Game Loop
// =============================================================================
/**
 * Main update function
 */
function update() {
    try {
        updateEngineSound();
        pollGamepad();
        
        // Game over state
        if (gameOver) {
            if (isRestartPressed()) {
                init();
            }
            
            if (deathTimer > 0) {
                decrementDeathTimer();
                updateParticles();
            }
            return;
        }
        
        // Respawn timer
        if (respawnTimer > 0) {
            decrementRespawnTimer();
            updateParticles();
            clearBulletsNearSpawn();
            return;
        }
        
        // Level transition timer
        if (levelTransitionTimer > 0) {
            decrementLevelTransitionTimer();
            updateParticles();
            return;
        }
        
        // Boss defeated timer
        if (bossDefeatedTimer > 0) {
            decrementBossDefeatedTimer();
            updateParticles();
            if (bossDefeatedTimer === 1) {
                advanceChapter();
                setLevelTransitionTimer(LEVEL_TRANSITION_TIMER);
            }
            return;
        }
        
        // Chapter transition timer
        if (chapterTransitionTimer > 0) {
            decrementChapterTransitionTimer();
            updateParticles();
            return;
        }
        
        // Main game update
        incrementTime();
        incrementGameSpeed(0.00001);
        incrementChapterTimer();
        decrementInvulnerabilityTimer();
        
        // Chapter 4: Boss Fight
        if (chapter === 4) {
            // Spawn boss if not active
            if (!bossActive && harassers.length === 0) {
                spawnBoss();
                updateSectorDisplay();
            }
            
            updateBoss();
            handleBossFiring();
            updateBossBullets();
            
            // Bullets hitting boss
            handleBulletBossCollisions();
            
            // Boss bullets hitting player
            handleBossBulletPlayerCollisions();
            
            // Chapter 4 pickup movement and collection
            updatePickups();
            collectPickups();
            cleanupPickups();
        }
        
        // Player input & movement
        updatePlayerMovement();
        updateShield();
        handleShooting();
        handleWeaponCycling();
        handleMissileFiring();
        handleBoomba();
        
        // Missile cooldown
        decrementMissileCooldown();
        
        // Bullets
        updateBullets();
        updateMissiles();
        
        // Mini-boss spawning (level 2+, not during main boss)
        if (level >= 2 && chapter !== 4 && miniBosses.length === 0 && Math.random() < 0.003) {
            spawnMiniBoss();
        }
        
        // Mini-bosses
        updateMiniBosses();
        updateMiniBossBullets();
        handleMiniBossDeflection();
        handleMiniBossBulletPlayerCollisions();
        
        // Chapter-specific gameplay (Chapters 1-3)
        if (chapter !== 4) {
            handleSpawning();
            
            // Pickup spawning
            if (Math.random() < 0.008) spawnShieldPickup();
            if (Math.random() < 0.003) spawnHeart();
            if (Math.random() < 0.001) spawnInvulnPickup();
            
            // Update movement
            updateEnemies();
            updateTrenchBlocks();
            updatePickups();
            
            // Collisions
            handleTrenchCollisions();
            handleBulletEnemyCollisions();
            collectPickups();
            handleEnemyPlayerCollisions();
            
            // Cleanup
            cleanupEnemies();
            cleanupPickups();
        }
        
        // Particles
        updateParticles();
        
        // Check chapter time limit
        if (chapter !== 4 && chapterTimer >= getChapterDuration()) {
            advanceChapter();
        }
        
    } catch (error) {
        console.error('Update error:', error);
        setGameOver(true);
    }
}
/**
 * Main render function
 */
function render() {
    try {
        renderBackground();
        renderMiniBosses();
        renderMiniBossBullets();
        renderMissiles();
        renderBoss();
        renderBossBullets();
        renderTrenchBlocks();
        renderBullets();
        renderPickups();
        renderHearts();
        renderEnemies();
        renderParticles();
        renderBars();
        renderPlayer();
        
        // Overlays
        renderGameOver();
        renderLevelTransition();
        renderBossDefeated();
        renderChapterTransition();
        
        renderHUD();
        
    } catch (error) {
        console.error('Render error:', error);
    }
}
/**
 * Main game loop with fixed timestep
 */
function loop(currentTime) {
    if (!lastFrameTime) setLastFrameTime(currentTime);
    
    const deltaTime = currentTime - lastFrameTime;
    setLastFrameTime(currentTime);
    
    // Accumulate time
    adjustAccumulator(deltaTime);
    
    // Cap accumulator to prevent spiral of death
    if (accumulator > FRAME_DURATION * 5) {
        setAccumulator(FRAME_DURATION * 5);
    }
    
    // Run game logic at fixed 60 FPS
    while (accumulator >= FRAME_DURATION) {
        update();
        adjustAccumulator(-FRAME_DURATION);
    }
    
    // Always render
    render();
    
    requestAnimationFrame(loop);
}
// =============================================================================
// Bootstrap
// =============================================================================
/**
 * Start the game when DOM is ready
 */
function bootstrap() {
    // Get canvas and context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    setCanvas(canvas, ctx);
    
    // Get DOM elements
    setDOMElements({
        scoreEl: document.getElementById('score'),
        levelEl: document.getElementById('levelNum'),
        sectorEl: document.getElementById('sector'),
        alertEl: document.getElementById('alert'),
        overlay: document.getElementById('overlay')
    });
    
    // Initialize input
    initInput();
    
    // Handle window resize
    window.addEventListener('resize', resize);
    
    // Initialize title screen
    initTitleScreen();
    
    // Handle title screen click to start game
    overlay.addEventListener('click', () => {
        stopTitleScreen();
        overlay.style.display = 'none';
        initAudio();
        init();
        setLastFrameTime(0);
        setAccumulator(0);
        requestAnimationFrame(loop);
    });
    
    // Handle title screen resize
    window.addEventListener('resize', () => {
        if (overlay.style.display !== 'none') {
            initTitleScreen();
        }
    });
}
// Start when DOM is ready
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', bootstrap);
} else {
    bootstrap();
}

</script>
</body>
</html>
