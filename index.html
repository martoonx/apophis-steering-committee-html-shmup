<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Apophis v24 - Missile System</title>
<style>
body { margin: 0; background: #000; overflow: hidden; font-family: 'Courier New', Courier, monospace; }
canvas { display: block; cursor: none; }
#hud { position: absolute; top: 20px; left: 20px; color: #00ffff; font-size: 24px; text-shadow: 0 0 10px #00ffff; z-index: 10; }
#levelDisplay { position: absolute; top: 60px; left: 20px; color: #ff00ff; font-size: 20px; text-shadow: 0 0 10px #ff00ff; z-index: 10; }
#sector { position: absolute; top: 20px; right: 20px; color: #ff00ff; font-size: 20px; text-shadow: 0 0 10px #ff00ff; z-index: 10; }
#alert {
position: absolute; top: 20%; left: 50%; transform: translateX(-50%);
color: #ffffff; font-size: 40px; text-shadow: 0 0 20px #fff;
display: none; z-index: 15; pointer-events: none; text-align: center;
}
#instructions { position: absolute; bottom: 20px; left: 20px; color: #00ffff; font-size: 14px; text-shadow: 0 0 5px #00ffff; z-index: 10; }
#version { position: absolute; bottom: 20px; right: 20px; color: #00ffff; font-size: 14px; text-shadow: 0 0 5px #00ffff; z-index: 10; }
#overlay {
position: absolute; top: 0; left: 0; width: 100%; height: 100%;
background: #000; display: flex; justify-content: center;
align-items: center; z-index: 20;
}
#titleCanvas {
width: 100%; height: 100%;
}
</style>
</head>
<body>
<div id="overlay">
<canvas id="titleCanvas"></canvas>
</div>
<div id="alert">TRENCH RUN ACTIVATED</div>
<div id="hud">Score: <span id="score">0</span></div>
<div id="levelDisplay">LEVEL: <span id="levelNum">1</span></div>
<div id="sector">SECTOR: OPEN SPACE</div>
<div id="instructions">
←→/AD Move | Z/SPACE Shoot | V Missile | X Shield | C Boomba | ↑↓/WS Weapon | R Restart
</div>
<div id="version">APOPHIS v24.0</div>
<canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('levelNum');
        const sectorEl = document.getElementById('sector');
        const alertEl = document.getElementById('alert');
        const overlay = document.getElementById('overlay');
        
        // Title screen
        const titleCanvas = document.getElementById('titleCanvas');
        const titleCtx = titleCanvas.getContext('2d');
        let titleStars = [];
        let titleTime = 0;
        let titleAnimationId = null;
        
        function initTitleScreen() {
            titleCanvas.width = window.innerWidth;
            titleCanvas.height = window.innerHeight;
            
            // Create twinkling stars
            titleStars = [];
            for (let i = 0; i < 200; i++) {
                titleStars.push({
                    x: Math.random() * titleCanvas.width,
                    y: Math.random() * titleCanvas.height,
                    size: Math.random() * 2 + 0.5,
                    twinkleSpeed: Math.random() * 0.05 + 0.02,
                    twinkleOffset: Math.random() * Math.PI * 2
                });
            }
            
            renderTitleScreen();
        }
        
        function renderTitleScreen() {
            const w = titleCanvas.width;
            const h = titleCanvas.height;
            titleTime++;
            
            // Clear
            titleCtx.fillStyle = '#000';
            titleCtx.fillRect(0, 0, w, h);
            
            // Draw twinkling stars
            titleStars.forEach(star => {
                const twinkle = Math.sin(titleTime * star.twinkleSpeed + star.twinkleOffset);
                const alpha = 0.3 + twinkle * 0.7;
                const size = star.size * (0.8 + twinkle * 0.4);
                titleCtx.fillStyle = `rgba(255, 255, 255, ${Math.max(0, alpha)})`;
                titleCtx.beginPath();
                titleCtx.arc(star.x, star.y, size, 0, Math.PI * 2);
                titleCtx.fill();
            });
            
            // Calculate center and scaling - fit everything on screen
            const centerX = w / 2;
            const scale = Math.min(w / 800, h / 600);
            const lineHeight = 38 * scale; // More row padding
            const startY = 30 * scale;
            
            // Title with color cycling glow
            const hue = (titleTime * 2) % 360;
            titleCtx.font = `bold ${42 * scale}px Courier New`;
            titleCtx.textAlign = 'center';
            titleCtx.shadowBlur = 30;
            titleCtx.shadowColor = `hsl(${hue}, 100%, 50%)`;
            titleCtx.fillStyle = '#00ffff';
            titleCtx.fillText('A P O P H I S', centerX, startY + lineHeight);
            
            titleCtx.font = `${12 * scale}px Courier New`;
            titleCtx.shadowBlur = 10;
            titleCtx.shadowColor = '#ff00ff';
            titleCtx.fillStyle = '#ff00ff';
            titleCtx.fillText('STEERING COMMITTEE-26', centerX, startY + lineHeight * 1.5);
            
            // Section: ENEMIES
            let y = startY + lineHeight * 2.3;
            titleCtx.font = `bold ${16 * scale}px Courier New`;
            titleCtx.shadowBlur = 15;
            titleCtx.shadowColor = '#ff0000';
            titleCtx.fillStyle = '#ff0000';
            titleCtx.fillText('— ENEMIES —', centerX, y);
            
            y += lineHeight * 0.8;
            // Tighter column spacing
            const col1 = centerX - 160 * scale; // Icon
            const col2 = centerX - 100 * scale; // Name
            const col3 = centerX + 50 * scale;  // Points
            const col4 = centerX + 100 * scale; // Description
            
            titleCtx.font = `${13 * scale}px Courier New`;
            titleCtx.textAlign = 'left';
            
            // Enemy (square)
            drawTitleEnemy(col1, y, scale);
            titleCtx.shadowBlur = 8;
            titleCtx.shadowColor = '#ff0000';
            titleCtx.fillStyle = '#ff0000';
            titleCtx.fillText('ENEMY', col2, y + 5);
            titleCtx.fillStyle = '#ffffff';
            titleCtx.fillText('50', col3, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('POINTS', col4, y + 5);
            
            // Blockdot
            y += lineHeight;
            drawTitleBlockdot(col1, y, scale);
            titleCtx.shadowColor = '#ff6600';
            titleCtx.fillStyle = '#ff6600';
            titleCtx.fillText('BLOCKDOT', col2, y + 5);
            titleCtx.fillStyle = '#ffffff';
            titleCtx.fillText('200', col3, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('PTS + BOOMBA', col4, y + 5);
            
            // Mini-boss
            y += lineHeight;
            drawTitleMiniBoss(col1, y, scale);
            titleCtx.shadowColor = '#ff0000';
            titleCtx.fillStyle = '#ff0000';
            titleCtx.fillText('MINI-BOSS', col2, y + 5);
            titleCtx.fillStyle = '#ffffff';
            titleCtx.fillText('1000', col3, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.textAlign = 'left';
            titleCtx.fillText('PTS + LOOT', col4, y + 5);
            y += lineHeight * 0.45;
            titleCtx.fillStyle = '#ff6666';
            titleCtx.font = `${11 * scale}px Courier New`;
            titleCtx.fillText('IMMUNE TO BULLETS', col4, y + 5);
            titleCtx.font = `${13 * scale}px Courier New`;
            
            // Harasser (Boss)
            y += lineHeight * 0.8;
            drawTitleHarasser(col1, y, scale);
            titleCtx.shadowColor = '#ff00ff';
            titleCtx.fillStyle = '#ff00ff';
            titleCtx.fillText('HARASSER', col2, y + 5);
            titleCtx.fillStyle = '#ffffff';
            titleCtx.fillText('5000', col3, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('PTS (BOSS)', col4, y + 5);
            y += lineHeight * 0.45;
            titleCtx.fillStyle = '#ff66ff';
            titleCtx.font = `${11 * scale}px Courier New`;
            titleCtx.fillText('IMMUNE TO MISSILES', col4, y + 5);
            titleCtx.font = `${13 * scale}px Courier New`;
            
            // Section: PICKUPS
            y += lineHeight * 0.9;
            titleCtx.textAlign = 'center';
            titleCtx.font = `bold ${16 * scale}px Courier New`;
            titleCtx.shadowBlur = 15;
            titleCtx.shadowColor = '#00ff00';
            titleCtx.fillStyle = '#00ff00';
            titleCtx.fillText('— PICKUPS —', centerX, y);
            
            y += lineHeight * 0.8;
            titleCtx.font = `${13 * scale}px Courier New`;
            titleCtx.textAlign = 'left';
            
            // Shield
            drawTitlePickup(col1, y, 's', '#ffff00', scale);
            titleCtx.shadowColor = '#ffff00';
            titleCtx.fillStyle = '#ffff00';
            titleCtx.fillText('SHIELD', col2, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('RESTORE SHIELD', col3, y + 5);
            
            // Weapon
            y += lineHeight;
            drawTitlePickup(col1, y, 'W', '#00ffff', scale);
            titleCtx.shadowColor = '#00ffff';
            titleCtx.fillStyle = '#00ffff';
            titleCtx.fillText('WEAPON', col2, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('NEW WEAPON', col3, y + 5);
            
            // Missile
            y += lineHeight;
            drawTitlePickup(col1, y, 'M', '#ff6600', scale);
            titleCtx.shadowColor = '#ff6600';
            titleCtx.fillStyle = '#ff6600';
            titleCtx.fillText('MISSILE', col2, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('+2 MISSILES', col3, y + 5);
            
            // Boomba
            y += lineHeight;
            drawTitlePickup(col1, y, 'B', '#ff6600', scale);
            titleCtx.shadowColor = '#ff6600';
            titleCtx.fillStyle = '#ff6600';
            titleCtx.fillText('BOOMBA', col2, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('SCREEN CLEAR', col3, y + 5);
            
            // Heart
            y += lineHeight;
            drawTitleHeart(col1, y, scale);
            titleCtx.shadowColor = '#00ff00';
            titleCtx.fillStyle = '#00ff00';
            titleCtx.fillText('HEART', col2, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('+1 HEALTH', col3, y + 5);
            
            // Extra Life
            y += lineHeight;
            drawTitleShip(col1, y, scale);
            titleCtx.shadowColor = '#00ffff';
            titleCtx.fillStyle = '#00ffff';
            titleCtx.fillText('EXTRA LIFE', col2, y + 5);
            titleCtx.fillStyle = '#888888';
            titleCtx.fillText('+1 LIFE', col3, y + 5);
            
            // Press to start - position relative to content, not fixed to bottom
            y += lineHeight * 1.2;
            titleCtx.textAlign = 'center';
            titleCtx.font = `${18 * scale}px Courier New`;
            const blink = Math.sin(titleTime * 0.08) > 0;
            if (blink) {
                titleCtx.shadowBlur = 20;
                titleCtx.shadowColor = '#00ffff';
                titleCtx.fillStyle = '#00ffff';
                titleCtx.fillText('CLICK TO INITIALIZE SYSTEMS', centerX, y);
            }
            
            // Controls hint - brighter
            y += lineHeight * 0.8;
            titleCtx.font = `${10 * scale}px Courier New`;
            titleCtx.shadowBlur = 10;
            titleCtx.shadowColor = '#00aaaa';
            titleCtx.fillStyle = '#00cccc';
            titleCtx.fillText('←→/AD Move | Z/SPACE Shoot | V Missile | X Shield | C Boomba', centerX, y);
            
            titleAnimationId = requestAnimationFrame(renderTitleScreen);
        }
        
        // Draw helper functions for title screen sprites
        function drawTitleEnemy(x, y, scale) {
            // SQUARE enemy - matches in-game appearance
            titleCtx.save();
            titleCtx.translate(x, y);
            titleCtx.scale(scale, scale);
            titleCtx.strokeStyle = '#ff0000';
            titleCtx.shadowColor = '#ff0000';
            titleCtx.shadowBlur = 10;
            titleCtx.lineWidth = 2;
            titleCtx.strokeRect(-10, -10, 20, 20);
            titleCtx.restore();
        }
        
        function drawTitleBlockdot(x, y, scale) {
            // SQUARE blockdot with inner dot - matches in-game appearance
            titleCtx.save();
            titleCtx.translate(x, y);
            titleCtx.scale(scale, scale);
            titleCtx.strokeStyle = '#ff6600';
            titleCtx.shadowColor = '#ff6600';
            titleCtx.shadowBlur = 10;
            titleCtx.lineWidth = 2;
            titleCtx.strokeRect(-12, -12, 24, 24);
            // Inner glowing dot
            titleCtx.fillStyle = '#ffff00';
            titleCtx.shadowColor = '#ffff00';
            titleCtx.beginPath();
            titleCtx.arc(0, 0, 5, 0, Math.PI * 2);
            titleCtx.fill();
            titleCtx.restore();
        }
        
        function drawTitleMiniBoss(x, y, scale) {
            titleCtx.save();
            titleCtx.translate(x, y);
            titleCtx.scale(scale, scale);
            titleCtx.strokeStyle = '#ff0000';
            titleCtx.shadowColor = '#ff0000';
            titleCtx.shadowBlur = 15;
            titleCtx.lineWidth = 3;
            titleCtx.beginPath();
            titleCtx.moveTo(0, -12);
            titleCtx.lineTo(15, 0);
            titleCtx.lineTo(0, 12);
            titleCtx.lineTo(-15, 0);
            titleCtx.closePath();
            titleCtx.stroke();
            // Inner accent
            titleCtx.strokeStyle = '#ffff00';
            titleCtx.shadowColor = '#ffff00';
            titleCtx.lineWidth = 1;
            titleCtx.beginPath();
            titleCtx.arc(0, 0, 5, 0, Math.PI * 2);
            titleCtx.stroke();
            titleCtx.restore();
        }
        
        function drawTitleHarasser(x, y, scale) {
            titleCtx.save();
            titleCtx.translate(x, y);
            titleCtx.scale(scale, scale);
            titleCtx.strokeStyle = '#ff00ff';
            titleCtx.shadowColor = '#ff00ff';
            titleCtx.shadowBlur = 20;
            titleCtx.lineWidth = 4;
            titleCtx.beginPath();
            titleCtx.moveTo(0, -15);
            titleCtx.lineTo(20, 0);
            titleCtx.lineTo(0, 15);
            titleCtx.lineTo(-20, 0);
            titleCtx.closePath();
            titleCtx.stroke();
            titleCtx.restore();
        }
        
        function drawTitlePickup(x, y, letter, color, scale) {
            titleCtx.save();
            titleCtx.translate(x, y);
            titleCtx.scale(scale, scale);
            titleCtx.strokeStyle = color;
            titleCtx.shadowColor = color;
            titleCtx.shadowBlur = 10;
            titleCtx.lineWidth = 2;
            titleCtx.beginPath();
            titleCtx.arc(0, 0, 12, 0, Math.PI * 2);
            titleCtx.stroke();
            titleCtx.fillStyle = color;
            titleCtx.font = 'bold 12px Courier New';
            titleCtx.textAlign = 'center';
            titleCtx.fillText(letter, 0, 4);
            titleCtx.restore();
        }
        
        function drawTitleHeart(x, y, scale) {
            // Match in-game heart: green stroke outline
            titleCtx.save();
            titleCtx.translate(x, y);
            const sz = 12 * scale;
            titleCtx.strokeStyle = '#00ff00';
            titleCtx.shadowColor = '#00ff00';
            titleCtx.shadowBlur = 15;
            titleCtx.lineWidth = 2;
            titleCtx.beginPath();
            titleCtx.moveTo(0, sz/4);
            titleCtx.bezierCurveTo(0, -sz/4, -sz, -sz/4, -sz, sz/4);
            titleCtx.bezierCurveTo(-sz, sz, 0, sz * 1.2, 0, sz * 1.5);
            titleCtx.bezierCurveTo(0, sz * 1.2, sz, sz, sz, sz/4);
            titleCtx.bezierCurveTo(sz, -sz/4, 0, -sz/4, 0, sz/4);
            titleCtx.stroke();
            titleCtx.restore();
        }
        
        function drawTitleShip(x, y, scale) {
            titleCtx.save();
            titleCtx.translate(x, y);
            titleCtx.scale(scale * 0.5, scale * 0.5);
            titleCtx.strokeStyle = '#00ffff';
            titleCtx.shadowColor = '#00ffff';
            titleCtx.shadowBlur = 15;
            titleCtx.lineWidth = 3;
            titleCtx.beginPath();
            titleCtx.moveTo(0, -20);
            titleCtx.lineTo(-25, 10);
            titleCtx.lineTo(0, 3);
            titleCtx.lineTo(25, 10);
            titleCtx.closePath();
            titleCtx.stroke();
            titleCtx.restore();
        }
        
        // Initialize title screen on load
        window.addEventListener('load', initTitleScreen);
        window.addEventListener('resize', () => {
            if (overlay.style.display !== 'none') {
                initTitleScreen();
            }
        });

        let width, height, gameSpeed, score, gameOver, time, shipX, shipY, shipAngle;
        let bullets, enemies, particles, stars, pickups, trenchBlocks, hearts;
        let harassers = [], harasserBullets = [];
        let miniBosses = [], miniBossBullets = [];
        let shieldLevel = 100;
        let shieldActive = false;
        let health = 3;
        let maxHealth = 3;
        let lives = 3;
        let deathTimer = 0;
        let respawnTimer = 0;
        let level = 1;
        let chapter = 1;
        let chapterTimer = 0;
        let bossActive = false;
        let bossDefeatedTimer = 0;
        let bossScoreGained = 0;
        let bossBulletSequence = [6, 7, 2];
        let bossBulletBurst = 0;
        let bossBulletPhase = 0;
        let bossBulletCooldown = 0;
        let levelTransitionTimer = 0;
        let chapterTransitionTimer = 0;
        
        // Player upgrades
        let currentWeapon = 0;
        let weaponInventory = [0];
        let boombaQueue = []; // Array storing boombas in order collected: 'area', 'screen', 'charged'
        let chargingBoomba = false;
        let boombaCharge = 0;
        let invulnerabilityTimer = 0;
        
        // Missile system
        let missiles = [];
        let missileAmmo = 3;
        const maxMissileAmmo = 10;
        let missileCooldown = 0;
        
        // Frame rate control - lock to 60 FPS
        const TARGET_FPS = 60;
        const FRAME_DURATION = 1000 / TARGET_FPS; // ~16.67ms per frame
        let lastFrameTime = 0;
        let accumulator = 0;
        
        const fovScale = 0.75;
        const enemyWorldLanes = [-350, -220, -120, 0, 120, 220, 350];
        const keys = {};

        let audioCtx, engineOsc, engineGain, bossOsc, bossGain;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Engine sound
            engineOsc = audioCtx.createOscillator();
            engineGain = audioCtx.createGain();
            engineOsc.type = 'sawtooth';
            engineOsc.frequency.setValueAtTime(45, audioCtx.currentTime);
            engineGain.gain.setValueAtTime(0, audioCtx.currentTime);
            engineOsc.connect(engineGain);
            engineGain.connect(audioCtx.destination);
            engineOsc.start();
            
            // Boss sound
            bossOsc = audioCtx.createOscillator();
            bossGain = audioCtx.createGain();
            bossOsc.type = 'triangle';
            bossOsc.frequency.setValueAtTime(100, audioCtx.currentTime);
            bossGain.gain.setValueAtTime(0, audioCtx.currentTime);
            bossOsc.connect(bossGain);
            bossGain.connect(audioCtx.destination);
            bossOsc.start();
        }

        function updateEngineSound() {
            if (!audioCtx || gameOver || levelTransitionTimer > 0 || chapterTransitionTimer > 0 || bossDefeatedTimer > 0) {
                if (engineGain) engineGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
                if (bossGain) bossGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.05);
                return;
            }
            engineGain.gain.setTargetAtTime(shieldActive ? 0.15 : 0.06, audioCtx.currentTime, 0.1);
            const pitchShift = 45 + (Math.abs(shipAngle) * 80) + (shieldActive ? 20 : 0);
            engineOsc.frequency.setTargetAtTime(pitchShift, audioCtx.currentTime, 0.05);
            
            // Boss sound - follows boss movement
            if (harassers.length > 0) {
                const boss = harassers[0];
                const bossFreq = 100 + (boss.x / width) * 100 + Math.sin(boss.phase * 2) * 30;
                bossOsc.frequency.setTargetAtTime(bossFreq, audioCtx.currentTime, 0.05);
                bossGain.gain.setTargetAtTime(0.08, audioCtx.currentTime, 0.1);
            } else {
                bossGain.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
        }

        function playSound(freq, type, dur, vol) {
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            if(type === 'square') osc.frequency.exponentialRampToValueAtTime(10, audioCtx.currentTime + dur);
            g.gain.setValueAtTime(vol, audioCtx.currentTime);
            g.gain.linearRampToValueAtTime(0, audioCtx.currentTime + dur);
            osc.connect(g); g.connect(audioCtx.destination);
            osc.start(); osc.stop(audioCtx.currentTime + dur);
        }

        function init() {
            gameSpeed = 0.08; score = 0; gameOver = false; time = 0;
            bullets = []; enemies = []; particles = []; pickups = []; trenchBlocks = []; hearts = [];
            harassers = []; harasserBullets = [];
            miniBosses = []; miniBossBullets = [];
            shipAngle = 0; shieldLevel = 100; shieldActive = false; health = 3; lives = 3; deathTimer = 0; respawnTimer = 0;
            level = 1; chapter = 1; chapterTimer = 0;
            bossActive = false; bossDefeatedTimer = 0; bossScoreGained = 0;
            bossBulletBurst = 0; bossBulletPhase = 0; bossBulletCooldown = 0;
            levelTransitionTimer = 0; chapterTransitionTimer = 0;
            currentWeapon = 0; weaponInventory = [0];
            boombaQueue = [];
            chargingBoomba = false; boombaCharge = 0;
            invulnerabilityTimer = 0;
            missiles = []; missileAmmo = 3; missileCooldown = 0;
            scoreEl.textContent = score;
            levelEl.textContent = level;
            resize();
            stars = Array.from({length: 150}, () => ({
                x: Math.random() * width, y: Math.random() * height,
                z: Math.random(), speed: Math.random() * 0.02 + 0.005
            }));
            updateSectorDisplay();
        }
        
        function updateSectorDisplay() {
            const chapterNames = ['OPEN SPACE', 'PLANETSIDE', 'TRENCH CANYON', 'BOSS SECTOR'];
            sectorEl.innerText = `LEVEL ${level} - ${chapterNames[chapter - 1]}`;
        }
        
        function getChapterDuration() {
            // First 3 chapters: 20 seconds each (20 * 60 frames = 1200 frames)
            // Chapter 4 (boss): no time limit
            if (chapter <= 3) {
                return 1200; // 20 seconds at 60fps
            }
            return Infinity; // Boss chapter has no time limit
        }
        
        function advanceChapter() {
            chapterTimer = 0;
            chapter++;
            
            if (chapter > 4) {
                // Level complete! Advance to next level, start at chapter 1
                level++;
                chapter = 1;
                levelEl.textContent = level;
                enemies = [];
                trenchBlocks = [];
                pickups = [];
                hearts = [];
                miniBosses = []; // Clear mini-bosses when advancing levels
                miniBossBullets = [];
                missiles = []; // Clear any in-flight missiles
                // Note: levelTransitionTimer is set when boss is defeated
            } else {
                // Chapter transition - keep mini-bosses alive!
                chapterTransitionTimer = 120;
                enemies = [];
                trenchBlocks = [];
                pickups = [];
                hearts = [];
                // DON'T clear miniBosses or miniBossBullets - they persist!
            }
            
            updateSectorDisplay();
        }

        function resize() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            shipX = width / 2; shipY = height * 0.8;
        }

        function createExplosion(x, y) {
            const colors = ['#00ffff', '#ff00ff', '#ffffff', '#ffff00'];
            for (let i = 0; i < 25; i++) {
                particles.push({
                    x, y, vx: (Math.random() - 0.5) * 20, vy: (Math.random() - 0.5) * 20,
                    life: 50, color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }

        function createDamageExplosion(x, y) {
            const colors = ['#ff0000', '#ff6600', '#ffff00', '#ff00ff', '#00ffff', '#ffffff'];
            for (let i = 0; i < 40; i++) {
                const angle = (Math.PI * 2 * i) / 40;
                const speed = 15 + Math.random() * 10;
                particles.push({
                    x, y, 
                    vx: Math.cos(angle) * speed, 
                    vy: Math.sin(angle) * speed,
                    life: 60, 
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }

        function createSpectacularExplosion(x, y) {
            const colors = ['#ff0000', '#ff6600', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#00ff00'];
            for (let i = 0; i < 80; i++) {
                const angle = (Math.PI * 2 * i) / 80;
                const speed = 20 + Math.random() * 15;
                particles.push({
                    x, y, 
                    vx: Math.cos(angle) * speed, 
                    vy: Math.sin(angle) * speed,
                    life: 80, 
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 10 + Math.random() * 8;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 70,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }
        
        function createMegaBossExplosion(x, y) {
            const colors = ['#ff0000', '#ff6600', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#00ff00', '#ff0066', '#6600ff', '#ff3300'];
            
            // Massive outer ring
            for (let i = 0; i < 720; i++) {
                const angle = (Math.PI * 2 * i) / 720;
                const speed = 30 + Math.random() * 25;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 120,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            
            // Medium ring
            for (let i = 0; i < 360; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 20 + Math.random() * 15;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 100,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            
            // Inner explosion
            for (let i = 0; i < 240; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 10 + Math.random() * 10;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 130,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            
            // Spiral patterns
            for (let i = 0; i < 180; i++) {
                const angle = (Math.PI * 8 * i) / 180;
                const speed = 22 + (i * 0.4);
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 110,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            
            // Shockwave rings
            for (let ring = 0; ring < 5; ring++) {
                for (let i = 0; i < 120; i++) {
                    const angle = (Math.PI * 2 * i) / 120;
                    const speed = 25 + ring * 8;
                    particles.push({
                        x, y,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 100 + ring * 10,
                        color: colors[ring * 2 % colors.length]
                    });
                }
            }
        }

        function createUltimateExplosion(x, y) {
            const colors = ['#ff0000', '#ff6600', '#ffff00', '#ff00ff', '#00ffff', '#ffffff', '#00ff00', '#ff0066', '#6600ff'];
            for (let i = 0; i < 240; i++) {
                const angle = (Math.PI * 2 * i) / 240;
                const speed = 25 + Math.random() * 20;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 100,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            for (let i = 0; i < 120; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 15 + Math.random() * 12;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 90,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            for (let i = 0; i < 80; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 8 + Math.random() * 6;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 110,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            for (let i = 0; i < 60; i++) {
                const angle = (Math.PI * 4 * i) / 60;
                const speed = 18 + (i * 0.3);
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 85,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }
        
        // Missile impact explosion
        function createMissileExplosion(x, y) {
            const colors = ['#ff6600', '#ff3300', '#ffaa00', '#ff0000', '#ffffff', '#ffff00'];
            for (let i = 0; i < 60; i++) {
                const angle = (Math.PI * 2 * i) / 60;
                const speed = 18 + Math.random() * 12;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 70,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
            for (let i = 0; i < 40; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 8 + Math.random() * 8;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 50,
                    color: '#ffffff'
                });
            }
        }
        
        // Bullet deflection spark
        function createDeflectionSpark(x, y) {
            const colors = ['#ffff00', '#ffffff', '#00ffff'];
            for (let i = 0; i < 8; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = 4 + Math.random() * 4;
                particles.push({
                    x, y,
                    vx: Math.cos(angle) * speed,
                    vy: Math.sin(angle) * speed,
                    life: 15,
                    color: colors[Math.floor(Math.random() * colors.length)]
                });
            }
        }
        
        // Find valid missile target
        function findMissileTarget() {
            if (miniBosses.length > 0) {
                let closest = null;
                let closestDist = Infinity;
                miniBosses.forEach(mb => {
                    const dist = Math.hypot(mb.x - shipX, mb.y - shipY);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closest = mb;
                    }
                });
                return { target: closest, type: 'miniboss' };
            }
            if (harassers.length > 0) {
                return { target: harassers[0], type: 'boss' };
            }
            return null;
        }
        
        function fireMissile() {
            if (missileAmmo <= 0 || missileCooldown > 0) return false;
            
            const targetInfo = findMissileTarget();
            if (!targetInfo) return false;
            
            const target = targetInfo.target;
            
            missiles.push({
                x: shipX,
                y: shipY - 20,
                targetType: targetInfo.type,
                target: target,
                startX: shipX,
                startY: shipY - 20,
                progress: 0,
                speed: 0.025,
                trail: []
            });
            
            missileAmmo--;
            missileCooldown = 30;
            
            playSound(150, 'sawtooth', 0.4, 0.25);
            playSound(80, 'square', 0.3, 0.15);
            
            return true;
        }
        
        function fireWeapon() {
            const weapon = weaponInventory[currentWeapon];
            // Spawn from tip of ship (ship is drawn pointing up, tip is at shipY - 35)
            const bulletStartY = shipY - 35;
            
            // Chapters 2 & 3: Angle bullets toward horizon center
            const horizonCenterX = width / 2;
            const horizonCenterY = height * 0.3;
            
            if (chapter === 2 || chapter === 3) {
                // Calculate angle toward horizon center
                const dx = horizonCenterX - shipX;
                const dy = horizonCenterY - bulletStartY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                switch(weapon) {
                    case 0: // Default rapid shot
                        const speed0 = 12;
                        bullets.push({ 
                            x: shipX, 
                            y: bulletStartY, 
                            vx: (dx / distance) * speed0,
                            vy: (dy / distance) * speed0,
                            type: 'vertical', 
                            originX: shipX 
                        });
                        playSound(800, 'square', 0.1, 0.05);
                        break;
                    case 1: // Sine wave - angles toward horizon with oscillation
                        const speed1 = 12;
                        bullets.push({ 
                            x: shipX, 
                            y: bulletStartY, 
                            vx: (dx / distance) * speed1,
                            vy: (dy / distance) * speed1,
                            baseVx: (dx / distance) * speed1, // Store for sine wave
                            type: 'vertical-sine', 
                            phase: time, 
                            originX: shipX 
                        });
                        playSound(900, 'sine', 0.1, 0.05);
                        break;
                    case 2: // Scatter shot - 5 bullets with spread angles
                        const speed2 = 14;
                        for (let i = -2; i <= 2; i++) {
                            const spreadAngle = Math.atan2(dy, dx) + (i * 0.15); // Spread in radians
                            bullets.push({ 
                                x: shipX + i * 15, 
                                y: bulletStartY, 
                                vx: Math.cos(spreadAngle) * speed2,
                                vy: Math.sin(spreadAngle) * speed2,
                                type: 'vertical-scatter', 
                                spread: i, 
                                originX: shipX + i * 15 
                            });
                        }
                        playSound(700, 'square', 0.15, 0.08);
                        break;
                    case 3: // Laser - fast angled beam
                        const speed3 = 16;
                        bullets.push({ 
                            x: shipX, 
                            y: bulletStartY, 
                            vx: (dx / distance) * speed3,
                            vy: (dy / distance) * speed3,
                            type: 'vertical-laser', 
                            width: 8, 
                            originX: shipX 
                        });
                        playSound(1200, 'sawtooth', 0.2, 0.1);
                        break;
                }
            } else {
                // Chapters 1 & 4: Simple vertical bullets
                switch(weapon) {
                    case 0: // Default rapid shot
                        bullets.push({ x: shipX, y: bulletStartY, vy: -12, type: 'vertical', originX: shipX });
                        playSound(800, 'square', 0.1, 0.05);
                        break;
                    case 1: // Sine wave
                        bullets.push({ x: shipX, y: bulletStartY, vy: -12, vx: 0, type: 'vertical-sine', phase: time, originX: shipX });
                        playSound(900, 'sine', 0.1, 0.05);
                        break;
                    case 2: // Scatter shot
                        for (let i = -2; i <= 2; i++) {
                            bullets.push({ x: shipX + i * 15, y: bulletStartY, vy: -14, vx: i * 2, type: 'vertical-scatter', spread: i, originX: shipX + i * 15 });
                        }
                        playSound(700, 'square', 0.15, 0.08);
                        break;
                    case 3: // Laser
                        bullets.push({ x: shipX, y: bulletStartY, vy: -16, type: 'vertical-laser', width: 8, originX: shipX });
                        playSound(1200, 'sawtooth', 0.2, 0.1);
                        break;
                }
            }
        }
        
        function spawnMiniBoss() {
            const configs = [
                { fireRate: 20, chaosRate: 0.03, defense: 0.05, color1: '#ff0000', color2: '#ffff00', bulletType: 'line' },
                { fireRate: 15, chaosRate: 0.08, defense: 0.08, color1: '#ff0000', color2: '#0088ff', bulletType: 'circle' },
                { fireRate: 25, chaosRate: 0.02, defense: 0.12, color1: '#ff0000', color2: '#00ff00', bulletType: 'triangle' }
            ];
            const config = configs[Math.min(level - 2, configs.length - 1)];
            
            // Calculate HP based on level with random variance
            // Base: 12 HP at level 2, +3 HP per level, then add ±20% random variance
            // Results in ~15-25 shots needed (accounting for defense deflections)
            const baseHp = 12 + (level - 2) * 3;
            const variance = baseHp * 0.2;
            const actualHp = Math.floor(baseHp + (Math.random() * variance * 2 - variance));
            
            miniBosses.push({
                x: width / 2,
                y: height * 0.25,
                phase: 0,
                hp: actualHp,
                maxHp: actualHp,
                ...config
            });
        }
        
        function fireMiniBossBullet(mb) {
            const bullet = {
                x: mb.x,
                y: mb.y,
                vy: 5 + gameSpeed * 20,
                type: mb.bulletType
            };
            
            if (mb.bulletType === 'circle') {
                bullet.vy *= 0.7; // Slower
            } else if (mb.bulletType === 'triangle') {
                bullet.vy *= 0.6; // Even slower for homing
            }
            
            miniBossBullets.push(bullet);
            playSound(250, 'sine', 0.08, 0.04);
        }
        
        function launchAreaBoomba() {
            // Clear enemies in a radius around the player
            const radius = 400; // Area of effect
            const enemiesToRemove = [];
            
            enemies.forEach((e, idx) => {
                let ex, ey;
                if (e.verticalDrop) {
                    ex = e.x;
                    ey = e.y;
                } else {
                    ex = width/2 + e.worldLane * fovScale * e.z;
                    ey = height*0.3 + e.z * height*0.5;
                }
                
                const dist = Math.hypot(shipX - ex, shipY - ey);
                if (dist < radius) {
                    createExplosion(ex, ey);
                    enemiesToRemove.push(idx);
                    score += 50;
                }
            });
            
            // Remove in reverse order
            for (let i = enemiesToRemove.length - 1; i >= 0; i--) {
                enemies.splice(enemiesToRemove[i], 1);
            }
            
            // Slow down mini-bosses' fire rate
            miniBosses.forEach(mb => {
                mb.fireRate = Math.min(mb.fireRate + 5, 60); // Increase delay (slower firing)
            });
            
            // Clear nearby mini-boss bullets
            miniBossBullets = miniBossBullets.filter(mbb => {
                const dist = Math.hypot(shipX - mbb.x, shipY - mbb.y);
                if (dist < radius) {
                    createExplosion(mbb.x, mbb.y);
                    return false;
                }
                return true;
            });
            
            // Clear nearby boss bullets
            harasserBullets = harasserBullets.filter(hb => {
                const dist = Math.hypot(shipX - hb.x, shipY - hb.y);
                if (dist < radius) {
                    createExplosion(hb.x, hb.y);
                    return false;
                }
                return true;
            });
            
            // Destroy nearby single blocks (Chapter 2 obstacles)
            const blocksToRemove = [];
            trenchBlocks.forEach((b, idx) => {
                if (b.isSingleBlock) {
                    const bx = width/2 + b.worldLane * fovScale * b.z;
                    const by = height*0.3 + b.z * height*0.5;
                    const dist = Math.hypot(shipX - bx, shipY - by);
                    if (dist < radius) {
                        createExplosion(bx, by);
                        blocksToRemove.push(idx);
                        score += 100; // Bonus for clearing obstacles
                    }
                }
            });
            for (let i = blocksToRemove.length - 1; i >= 0; i--) {
                trenchBlocks.splice(blocksToRemove[i], 1);
            }
            
            scoreEl.textContent = score;
            playSound(120, 'square', 0.6, 0.3);
            
            // Visual feedback - expanding ring
            for (let ring = 0; ring < 5; ring++) {
                for (let i = 0; i < 40; i++) {
                    const angle = (Math.PI * 2 * i) / 40;
                    const speed = 15 + ring * 5;
                    particles.push({
                        x: shipX,
                        y: shipY,
                        vx: Math.cos(angle) * speed,
                        vy: Math.sin(angle) * speed,
                        life: 60,
                        color: '#ff6600'
                    });
                }
            }
        }
        
        function launchScreenBoomba() {
            // Clear ALL enemies on screen
            enemies.forEach(e => {
                let ex, ey;
                if (e.verticalDrop) {
                    ex = e.x;
                    ey = e.y;
                } else {
                    ex = width/2 + e.worldLane * fovScale * e.z;
                    ey = height*0.3 + e.z * height*0.5;
                }
                createExplosion(ex, ey);
                score += 50;
            });
            enemies = [];
            
            // Clear ALL bullets
            miniBossBullets.forEach(mbb => createExplosion(mbb.x, mbb.y));
            miniBossBullets = [];
            harasserBullets.forEach(hb => createExplosion(hb.x, hb.y));
            harasserBullets = [];
            
            // Damage mini-bosses heavily
            const miniBossesToRemove = [];
            miniBosses.forEach((mb, idx) => {
                mb.hp -= 15; // Heavy damage
                mb.fireRate = Math.min(mb.fireRate + 10, 60); // Significantly slow down firing
                createSpectacularExplosion(mb.x, mb.y);
                if (mb.hp <= 0) {
                    miniBossesToRemove.push(idx);
                    score += 1000;
                    // Alternate between extra life and weapon drop
                    const dropType = Math.random() < 0.5 ? 'extralife' : 'weapon';
                    pickups.push({ 
                        x: mb.x,
                        y: mb.y,
                        vx: 0,
                        vy: 2.5,
                        size: 25,
                        type: dropType,
                        verticalDrop: true
                    });
                    // Also drop missile ammo
                    pickups.push({ 
                        x: mb.x + 30,
                        y: mb.y,
                        vx: 0,
                        vy: 2.5,
                        size: 20,
                        type: 'missile',
                        verticalDrop: true
                    });
                }
            });
            for (let i = miniBossesToRemove.length - 1; i >= 0; i--) {
                miniBosses.splice(miniBossesToRemove[i], 1);
            }
            
            // Damage main boss
            harassers.forEach(h => {
                h.hp -= 25; // Heavy damage
                createMegaBossExplosion(h.x, h.y);
            });
            
            // Destroy ALL single blocks (Chapter 2 obstacles)
            const blocksToRemove = [];
            trenchBlocks.forEach((b, idx) => {
                if (b.isSingleBlock) {
                    const bx = width/2 + b.worldLane * fovScale * b.z;
                    const by = height*0.3 + b.z * height*0.5;
                    createExplosion(bx, by);
                    blocksToRemove.push(idx);
                    score += 100;
                }
            });
            for (let i = blocksToRemove.length - 1; i >= 0; i--) {
                trenchBlocks.splice(blocksToRemove[i], 1);
            }
            
            scoreEl.textContent = score;
            playSound(60, 'square', 1.2, 0.4);
            
            // Visual feedback - screen flash
            for (let i = 0; i < 200; i++) {
                particles.push({
                    x: Math.random() * width,
                    y: Math.random() * height,
                    vx: (Math.random() - 0.5) * 20,
                    vy: (Math.random() - 0.5) * 20,
                    life: 70,
                    color: ['#ff6600', '#ff0000', '#ffff00'][Math.floor(Math.random() * 3)]
                });
            }
        }
        
        function launchChargedBoomba() {
            const power = boombaCharge / 300;
            
            // Clear screen based on charge
            const enemiesToRemove = [];
            enemies.forEach((e, idx) => {
                if (Math.random() < power) {
                    createExplosion(width/2 + e.worldLane * fovScale * e.z, height*0.3 + e.z * height*0.5);
                    enemiesToRemove.push(idx);
                    score += 50;
                }
            });
            // Remove in reverse order to maintain indices
            for (let i = enemiesToRemove.length - 1; i >= 0; i--) {
                enemies.splice(enemiesToRemove[i], 1);
            }
            
            // Damage mini-bosses
            const miniBossesToRemove = [];
            miniBosses.forEach((mb, idx) => {
                mb.hp -= Math.floor(power * 10);
                // Slow down fire rate based on charge power
                mb.fireRate = Math.min(mb.fireRate + Math.floor(power * 8), 60);
                createExplosion(mb.x, mb.y);
                if (mb.hp <= 0) {
                    createSpectacularExplosion(mb.x, mb.y);
                    miniBossesToRemove.push(idx);
                    score += 1000;
                    // Alternate between extra life and weapon drop
                    const dropType = Math.random() < 0.5 ? 'extralife' : 'weapon';
                    pickups.push({ 
                        x: mb.x,
                        y: mb.y,
                        vx: 0,
                        vy: 2.5,
                        size: 25,
                        type: dropType,
                        verticalDrop: true
                    });
                    // Also drop missile ammo
                    pickups.push({ 
                        x: mb.x + 30,
                        y: mb.y,
                        vx: 0,
                        vy: 2.5,
                        size: 20,
                        type: 'missile',
                        verticalDrop: true
                    });
                }
            });
            for (let i = miniBossesToRemove.length - 1; i >= 0; i--) {
                miniBosses.splice(miniBossesToRemove[i], 1);
            }
            
            // Damage main boss
            harassers.forEach(h => {
                h.hp -= Math.floor(power * 20);
                createExplosion(h.x, h.y);
            });
            
            // Destroy single blocks based on charge level
            const blocksToRemove = [];
            trenchBlocks.forEach((b, idx) => {
                if (b.isSingleBlock && Math.random() < power) {
                    const bx = width/2 + b.worldLane * fovScale * b.z;
                    const by = height*0.3 + b.z * height*0.5;
                    createExplosion(bx, by);
                    blocksToRemove.push(idx);
                    score += 100;
                }
            });
            for (let i = blocksToRemove.length - 1; i >= 0; i--) {
                trenchBlocks.splice(blocksToRemove[i], 1);
            }
            
            scoreEl.textContent = score;
            playSound(80, 'square', 1.0, 0.3);
            
            // Visual feedback
            for (let i = 0; i < 100 * power; i++) {
                particles.push({
                    x: width / 2,
                    y: height / 2,
                    vx: (Math.random() - 0.5) * 30,
                    vy: (Math.random() - 0.5) * 30,
                    life: 80,
                    color: '#ffff00'
                });
            }
        }

        overlay.addEventListener('click', () => {
            // Stop title screen animation
            if (titleAnimationId) {
                cancelAnimationFrame(titleAnimationId);
                titleAnimationId = null;
            }
            overlay.style.display = 'none';
            initAudio(); init(); lastFrameTime = 0; accumulator = 0; requestAnimationFrame(loop);
        });

        window.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if (e.code === 'Space') e.preventDefault();
            if (gameOver && e.code === 'KeyR') init();
            
            // Weapon cycling - Arrow Up/Down and W/S
            if (e.code === 'ArrowUp' || e.code === 'KeyW') {
                currentWeapon = (currentWeapon + 1) % weaponInventory.length;
            }
            if (e.code === 'ArrowDown' || e.code === 'KeyS') {
                currentWeapon = (currentWeapon - 1 + weaponInventory.length) % weaponInventory.length;
            }
            
            // Missile firing - V key
            if (e.code === 'KeyV' && !gameOver && respawnTimer === 0) {
                fireMissile();
            }
        });
        window.addEventListener('keyup', (e) => keys[e.code] = false);

        function update() {
            try {
                updateEngineSound();
            
            if (gameOver) { 
                if (deathTimer > 0) {
                    deathTimer--;
                    particles.forEach(p => { 
                        p.x += p.vx; 
                        p.y += p.vy; 
                        p.life--; 
                        p.vx *= 0.98; 
                        p.vy *= 0.98; 
                    });
                    particles = particles.filter(p => p.life > 0);
                }
                return; 
            }
            
            // Handle respawn timer
            if (respawnTimer > 0) {
                respawnTimer--;
                particles.forEach(p => { 
                    p.x += p.vx; 
                    p.y += p.vy; 
                    p.life--; 
                    p.vx *= 0.98; 
                    p.vy *= 0.98; 
                });
                particles = particles.filter(p => p.life > 0);
                
                // Clear any enemy bullets near spawn point during respawn
                harasserBullets = harasserBullets.filter(hb => Math.hypot(hb.x - shipX, hb.y - shipY) > 200);
                miniBossBullets = miniBossBullets.filter(mbb => Math.hypot(mbb.x - shipX, mbb.y - shipY) > 200);
                
                // Also clear nearby enemies in chapter 1
                if (chapter === 1) {
                    enemies = enemies.filter(e => Math.hypot(e.x - shipX, e.y - shipY) > 150);
                }
                
                return;
            }
            
            if (levelTransitionTimer > 0) {
                levelTransitionTimer--;
                particles.forEach(p => { 
                    p.x += p.vx; 
                    p.y += p.vy; 
                    p.life--; 
                    p.vx *= 0.98; 
                    p.vy *= 0.98; 
                });
                particles = particles.filter(p => p.life > 0);
                return;
            }
            
            if (bossDefeatedTimer > 0) {
                bossDefeatedTimer--;
                particles.forEach(p => { 
                    p.x += p.vx; 
                    p.y += p.vy; 
                    p.life--; 
                    p.vx *= 0.98; 
                    p.vy *= 0.98; 
                });
                particles = particles.filter(p => p.life > 0);
                if (bossDefeatedTimer === 1) {
                    advanceChapter(); // This will set chapter to 1 and increment level
                    levelTransitionTimer = 180;
                }
                return;
            }
            
            if (chapterTransitionTimer > 0) {
                chapterTransitionTimer--;
                particles.forEach(p => { 
                    p.x += p.vx; 
                    p.y += p.vy; 
                    p.life--; 
                    p.vx *= 0.98; 
                    p.vy *= 0.98; 
                });
                particles = particles.filter(p => p.life > 0);
                return;
            }
            
            time++; gameSpeed += 0.00001;
            
            // Increment chapter timer for all chapters (including boss)
            chapterTimer++;
            
            // Update invulnerability
            if (invulnerabilityTimer > 0) invulnerabilityTimer--;

            // Chapter 4: Boss Fight
            if (chapter === 4) {
                // Spawn boss if not active
                if (!bossActive && harassers.length === 0) {
                    harassers.push({ 
                        x: width / 2, 
                        y: height * 0.2, 
                        phase: 0, 
                        hp: 40 + level * 15, 
                        maxHp: 40 + level * 15 
                    });
                    bossActive = true;
                    updateSectorDisplay();
                }

                // Boss behavior
                harassers.forEach(h => {
                    h.phase += 0.04;
                    if (!h.targetX || Math.random() < 0.02) {
                        h.targetX = width * (0.2 + Math.random() * 0.6);
                    }
                    const dx = h.targetX - h.x;
                    h.x += dx * 0.05 + (Math.random() - 0.5) * 8;
                    h.x = Math.max(width * 0.15, Math.min(width * 0.85, h.x));
                    h.y = height * 0.2 + Math.sin(h.phase * 2) * 15;
                });
                
                // Pulsed firing pattern: 6-7-2 sequence
                if (bossBulletCooldown > 0) {
                    bossBulletCooldown--;
                } else if (harassers.length > 0) {
                    const h = harassers[0];
                    // Fire a burst
                    if (time % 5 === 0) { // Fire every 5 frames during burst
                        harasserBullets.push({
                            x: h.x + (Math.random() - 0.5) * 120,
                            y: h.y, vy: 7 + (gameSpeed * 25), size: 4
                        });
                        playSound(200, 'sine', 0.1, 0.03);
                        bossBulletBurst++;
                        
                        // Check if burst is complete
                        if (bossBulletBurst >= bossBulletSequence[bossBulletPhase]) {
                            bossBulletBurst = 0;
                            bossBulletPhase = (bossBulletPhase + 1) % 3;
                            
                            // Set cooldown between bursts
                            if (bossBulletPhase === 0) {
                                bossBulletCooldown = 90; // Longer cooldown after full sequence
                            } else {
                                bossBulletCooldown = 30; // Short pause between bursts
                            }
                        }
                    }
                }

                // Bullets hitting boss
                bullets.forEach((bull, bi) => {
                    harassers.forEach((h, hi) => {
                        // Simple 2D collision for vertical bullets
                        const dist = Math.hypot(bull.x - h.x, bull.y - h.y);
                        
                        if (dist < 70) {
                            h.hp--;
                            bullets.splice(bi, 1);
                            createExplosion(h.x, h.y);
                            playSound(400, 'square', 0.05, 0.1);
                            if (h.hp <= 0) {
                                createMegaBossExplosion(h.x, h.y);
                                for(let i=0; i<15; i++) {
                                    setTimeout(() => {
                                        createSpectacularExplosion(h.x + (Math.random()-0.5)*150, h.y + (Math.random()-0.5)*150);
                                    }, i * 50);
                                }
                                harassers.splice(hi, 1);
                                harasserBullets = [];
                                bossActive = false;
                                bossScoreGained = 5000;
                                score += bossScoreGained;
                                scoreEl.textContent = score;
                                bossDefeatedTimer = 180; // 3 seconds
                                playSound(50, 'sawtooth', 1.5, 0.5);
                                
                                // After boss is defeated, we'll advance chapter when bossDefeatedTimer hits 0
                                // This is handled in the bossDefeatedTimer check which sets levelTransitionTimer
                            }
                        }
                    });
                });

                // Boss bullets hitting player
                harasserBullets.forEach((hb, index) => {
                    hb.y += hb.vy;
                    const dist = Math.hypot(hb.x - shipX, hb.y - shipY);
                    if (dist < 45 && respawnTimer === 0) { // Don't hit during respawn
                        if (shieldActive || invulnerabilityTimer > 0) {
                            harasserBullets.splice(index, 1);
                            score += 5;
                            scoreEl.textContent = score;
                        } else {
                            health--;
                            createDamageExplosion(shipX, shipY);
                            playSound(50, 'sawtooth', 0.5, 0.3);
                            harasserBullets.splice(index, 1);
                            if (health <= 0) {
                                lives--;
                                if (lives > 0) {
                                    // Respawn
                                    createUltimateExplosion(shipX, shipY);
                                    respawnTimer = 120; // 2 seconds
                                    health = 3;
                                    invulnerabilityTimer = 180; // 3 seconds invulnerability after respawn
                                } else {
                                    createUltimateExplosion(shipX, shipY);
                                    deathTimer = 180;
                                    gameOver = true;
                                }
                            }
                        }
                    }
                    if (hb.y > height || hb.y < 0) harasserBullets.splice(index, 1);
                });
                
                // Chapter 4: Move and collect pickups (from mini-boss drops)
                pickups.forEach((p, pi) => {
                    if (p.verticalDrop) {
                        p.y += p.vy; // Fall straight down
                    }
                });
                
                // Pickup collection in Chapter 4
                for (let pi = pickups.length - 1; pi >= 0; pi--) {
                    const p = pickups[pi];
                    if (p.verticalDrop && Math.hypot(shipX - p.x, shipY - p.y) < 60) {
                        if (p.type === 'weapon') {
                            const newWeapon = Math.floor(Math.random() * 3) + 1;
                            if (!weaponInventory.includes(newWeapon)) {
                                weaponInventory.push(newWeapon);
                            }
                            playSound(600, 'sine', 0.3, 0.2);
                        } else if (p.type === 'extralife') {
                            lives++;
                            playSound(900, 'sine', 0.5, 0.3);
                        } else if (p.type === 'missile') {
                            missileAmmo = Math.min(maxMissileAmmo, missileAmmo + 2);
                            playSound(550, 'sine', 0.3, 0.2);
                        } else if (p.type === 'shield') {
                            shieldLevel = Math.min(100, shieldLevel + 20);
                            playSound(600, 'sine', 0.3, 0.2);
                        }
                        pickups.splice(pi, 1);
                    }
                }
                
                // Cleanup pickups that fell off screen
                pickups = pickups.filter(p => !p.verticalDrop || p.y < height);
            }

            // Player movement - Arrow Keys and A/D
            if (keys['ArrowLeft'] || keys['KeyA']) shipAngle -= 0.15;
            if (keys['ArrowRight'] || keys['KeyD']) shipAngle += 0.15;
            shipAngle *= 0.88;
            shipX = Math.max(80, Math.min(width - 80, shipX + shipAngle * 12));

            // Shield - X key
            shieldActive = keys['KeyX'] && shieldLevel > 1 && !chargingBoomba && respawnTimer === 0;
            if (shieldActive) shieldLevel -= 0.5;
            else if (shieldLevel < 100) shieldLevel += 0.05;
            
            // Boomba deployment - C key
            if (keys['KeyC'] && boombaQueue.length > 0 && !chargingBoomba && respawnTimer === 0) {
                const nextBoomba = boombaQueue[0];
                
                if (nextBoomba === 'charged') {
                    chargingBoomba = true;
                    boombaCharge = 0;
                } else {
                    if (nextBoomba === 'area') {
                        launchAreaBoomba();
                    } else if (nextBoomba === 'screen') {
                        launchScreenBoomba();
                    }
                    boombaQueue.shift();
                }
            }
            
            // Handle charged boomba charging
            if (chargingBoomba) {
                if (keys['KeyC']) {
                    boombaCharge = Math.min(boombaCharge + 2, 300);
                } else {
                    launchChargedBoomba();
                    boombaQueue.shift();
                    chargingBoomba = false;
                    boombaCharge = 0;
                }
            }
            
            // Missile cooldown
            if (missileCooldown > 0) missileCooldown--;

            // Shooting - Z or Spacebar
            const fireDelay = 6;
            if ((keys['KeyZ'] || keys['Space']) && !chargingBoomba && respawnTimer === 0 && time % fireDelay === 0) {
                fireWeapon();
            }
            
            // Update bullets
            bullets.forEach(b => {
                // Chapters 2 & 3: Continuously home toward horizon center for perspective effect
                if ((chapter === 2 || chapter === 3) && b.vx !== undefined && b.vy !== undefined) {
                    const horizonCenterX = width / 2;
                    const horizonCenterY = height * 0.3;
                    
                    // Calculate direction to horizon from current position
                    const dx = horizonCenterX - b.x;
                    const dy = horizonCenterY - b.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    // Store distance for rendering (scaling bullets)
                    b.distanceToHorizon = distance;
                    
                    // Mark bullet as reached if close to horizon (terminate before reaching to protect spawning enemies)
                    if (distance <= 80) { // Terminate 80px before horizon
                        b.reachedHorizon = true;
                    }
                    
                    if (distance > 5) { // Don't update if already at horizon
                        const speed = 12;
                        b.vx = (dx / distance) * speed;
                        b.vy = (dy / distance) * speed;
                    }
                }
                
                // Apply velocity to position
                if (b.vx !== undefined) b.x += b.vx;
                if (b.vy !== undefined) b.y += b.vy;
                
                // Sine wave movement for chapters 1 & 4 (vertical only)
                if ((chapter === 1 || chapter === 4) && b.type === 'vertical-sine') {
                    b.x = b.originX + Math.sin((time - b.phase) * 0.2) * 50;
                }
            });
            
            // Cleanup bullets based on chapter
            if (chapter === 1 || chapter === 4) {
                // Chapters 1 & 4: Remove when off top of screen
                bullets = bullets.filter(b => b.y > -50);
            } else {
                // Chapters 2 & 3: Remove when they reach the horizon
                bullets = bullets.filter(b => !b.reachedHorizon);
            }
            
            // Update missiles
            for (let mi = missiles.length - 1; mi >= 0; mi--) {
                const m = missiles[mi];
                
                // Skip bounced missiles - they're handled separately
                if (m.bounced) continue;
                
                // Check if target still exists
                let targetExists = false;
                let targetX, targetY;
                
                if (m.targetType === 'miniboss') {
                    if (miniBosses.includes(m.target)) {
                        targetExists = true;
                        targetX = m.target.x;
                        targetY = m.target.y;
                    }
                } else if (m.targetType === 'boss') {
                    if (harassers.includes(m.target)) {
                        targetExists = true;
                        targetX = m.target.x;
                        targetY = m.target.y;
                    }
                }
                
                if (!targetExists) {
                    m.y -= 15;
                    if (m.y < -50) missiles.splice(mi, 1);
                    continue;
                }
                
                // Store trail
                m.trail.push({ x: m.x, y: m.y });
                if (m.trail.length > 8) m.trail.shift();
                
                // Progress along arc
                m.progress += m.speed;
                
                // Bezier curve for arc
                const arcSide = (m.startX < width / 2) ? 1 : -1;
                const controlX = (m.startX + targetX) / 2 + arcSide * 150;
                const controlY = Math.min(m.startY, targetY) - 100;
                
                const t = Math.min(m.progress, 1);
                const t1 = 1 - t;
                
                m.x = t1 * t1 * m.startX + 2 * t1 * t * controlX + t * t * targetX;
                m.y = t1 * t1 * m.startY + 2 * t1 * t * controlY + t * t * targetY;
                
                // Check for impact
                const dist = Math.hypot(m.x - targetX, m.y - targetY);
                if (dist < 40 || m.progress >= 1) {
                    
                    if (m.targetType === 'miniboss') {
                        // Missiles hit mini-bosses normally
                        createMissileExplosion(targetX, targetY);
                        playSound(60, 'sawtooth', 0.6, 0.4);
                        playSound(120, 'square', 0.4, 0.3);
                        
                        m.target.hp -= 8;
                        if (m.target.hp <= 0) {
                            const mbIndex = miniBosses.indexOf(m.target);
                            if (mbIndex !== -1) {
                                createSpectacularExplosion(m.target.x, m.target.y);
                                // Drop loot
                                if (Math.random() < 0.5) {
                                    pickups.push({ x: m.target.x, y: m.target.y, vx: 0, vy: 2, size: 25, type: 'weapon', verticalDrop: true });
                                } else {
                                    pickups.push({ x: m.target.x, y: m.target.y, vx: 0, vy: 2, size: 25, type: 'extralife', verticalDrop: true });
                                }
                                // Drop missile ammo
                                pickups.push({ x: m.target.x + 30, y: m.target.y, vx: 0, vy: 2.5, size: 20, type: 'missile', verticalDrop: true });
                                miniBosses.splice(mbIndex, 1);
                                score += 1000;
                                scoreEl.textContent = score;
                            }
                        }
                        missiles.splice(mi, 1);
                    } else if (m.targetType === 'boss') {
                        // Missiles BOUNCE off the main boss!
                        if (!m.bounced) {
                            // First hit - bounce!
                            createDeflectionSpark(m.x, m.y);
                            createDeflectionSpark(m.x + 10, m.y - 5);
                            createDeflectionSpark(m.x - 10, m.y + 5);
                            createDeflectionSpark(m.x, m.y + 10);
                            // Same ping sound as bullet deflection off mini-boss
                            playSound(1200, 'sine', 0.05, 0.08);
                            playSound(1200, 'sine', 0.08, 0.12); // Slightly louder/longer for missile
                            
                            // Calculate bounce angle - reflect downward and to a random side
                            const bounceAngle = Math.PI / 2 + (Math.random() - 0.5) * 1.5; // Mostly downward, more spread
                            const bounceSpeed = 12; // Faster bounce
                            
                            // Reset missile for bounce trajectory
                            m.bounced = true;
                            m.bounceVx = Math.cos(bounceAngle) * bounceSpeed;
                            m.bounceVy = Math.sin(bounceAngle) * bounceSpeed;
                            m.bounceLife = 120; // 2 seconds - longer visibility
                            m.trail = []; // Reset trail
                            
                            // Push missile out of boss collision zone
                            m.x = targetX + Math.cos(bounceAngle) * 60;
                            m.y = targetY + Math.sin(bounceAngle) * 60;
                        } else {
                            // Already bounced, remove it
                            missiles.splice(mi, 1);
                        }
                    }
                }
            }
            
            // Update bounced missiles
            for (let mi = missiles.length - 1; mi >= 0; mi--) {
                const m = missiles[mi];
                if (m.bounced) {
                    // Store trail - longer trail for visibility
                    m.trail.push({ x: m.x, y: m.y });
                    if (m.trail.length > 12) m.trail.shift();
                    
                    // Move with bounce velocity
                    m.x += m.bounceVx;
                    m.y += m.bounceVy;
                    m.bounceVy += 0.12; // Slightly less gravity so it stays visible longer
                    m.bounceLife--;
                    
                    // Remove if expired or off-screen
                    if (m.bounceLife <= 0 || m.y > height + 50 || m.x < -50 || m.x > width + 50) {
                        // Small explosion when it fizzles out
                        createDeflectionSpark(m.x, m.y);
                        missiles.splice(mi, 1);
                    }
                }
            }
            
            // Cleanup missiles
            missiles = missiles.filter(m => m.y > -100 && m.y < height + 100);
            
            // Mini-boss spawning (level 2+, not during main boss)
            if (level >= 2 && chapter !== 4 && miniBosses.length === 0 && Math.random() < 0.003) {
                spawnMiniBoss();
            }
            
            // Update mini-bosses
            miniBosses.forEach(mb => {
                mb.phase += 0.06;
                if (!mb.targetX || Math.random() < mb.chaosRate) {
                    mb.targetX = width * (0.2 + Math.random() * 0.6);
                }
                const dx = mb.targetX - mb.x;
                mb.x += dx * 0.08 + (Math.random() - 0.5) * mb.chaosRate * 50;
                mb.x = Math.max(width * 0.1, Math.min(width * 0.9, mb.x));
                mb.y = height * 0.25 + Math.sin(mb.phase * 2) * 20;
                
                // Mini-boss firing
                if (time % mb.fireRate === 0) {
                    fireMiniBossBullet(mb);
                }
            });
            
            // Mini-boss bullets
            miniBossBullets.forEach((mbb, index) => {
                mbb.y += mbb.vy;
                if (mbb.type === 'triangle' && mbb.y < height) {
                    // Homing behavior
                    const dx = shipX - mbb.x;
                    const dy = shipY - mbb.y;
                    const angle = Math.atan2(dy, dx);
                    mbb.x += Math.cos(angle) * 1.5;
                }
                
                const dist = Math.hypot(mbb.x - shipX, mbb.y - shipY);
                if (dist < 45) {
                    if (shieldActive || invulnerabilityTimer > 0) {
                        miniBossBullets.splice(index, 1);
                        score += 5;
                        scoreEl.textContent = score;
                    } else {
                        health--;
                        createDamageExplosion(shipX, shipY);
                        playSound(50, 'sawtooth', 0.5, 0.3);
                        miniBossBullets.splice(index, 1);
                        if (health <= 0) {
                            lives--;
                            if (lives > 0) {
                                // Respawn
                                createUltimateExplosion(shipX, shipY);
                                respawnTimer = 120; // 2 seconds
                                health = 3;
                                invulnerabilityTimer = 180;
                            } else {
                                createUltimateExplosion(shipX, shipY);
                                deathTimer = 180;
                                gameOver = true;
                            }
                        }
                    }
                }
                if (mbb.y > height || mbb.y < 0) miniBossBullets.splice(index, 1);
            });
            
            // Mini-bosses deflect bullets (only vulnerable to boombas and missiles)
            for (let bi = bullets.length - 1; bi >= 0; bi--) {
                const bull = bullets[bi];
                if (bull.bounced) continue; // Already bounced, don't bounce again
                
                for (let mi = 0; mi < miniBosses.length; mi++) {
                    const mb = miniBosses[mi];
                    const dist = Math.hypot(bull.x - mb.x, bull.y - mb.y);
                    if (dist < 35) {
                        createDeflectionSpark(bull.x, bull.y);
                        playSound(1200, 'sine', 0.05, 0.08);
                        
                        // Calculate bounce direction - reflect away from mini-boss
                        const dx = bull.x - mb.x;
                        const dy = bull.y - mb.y;
                        const angle = Math.atan2(dy, dx);
                        
                        // Add some randomness to the bounce angle
                        const bounceAngle = angle + (Math.random() - 0.5) * 0.8;
                        const bounceSpeed = 10 + Math.random() * 4;
                        
                        // Set new velocity
                        bull.vx = Math.cos(bounceAngle) * bounceSpeed;
                        bull.vy = Math.sin(bounceAngle) * bounceSpeed;
                        bull.bounced = true; // Mark as bounced
                        bull.bounceLife = 60; // Bounced bullets fade after 1 second
                        bull.type = 'bounced'; // Change type for different rendering
                        
                        // Push bullet outside collision zone
                        bull.x = mb.x + Math.cos(bounceAngle) * 40;
                        bull.y = mb.y + Math.sin(bounceAngle) * 40;
                        
                        break;
                    }
                }
            }
            
            // Update and cleanup bounced bullets
            bullets = bullets.filter(b => {
                if (b.bounced) {
                    b.bounceLife--;
                    return b.bounceLife > 0 && b.x > 0 && b.x < width && b.y > 0 && b.y < height;
                }
                return true;
            });

            // Chapter-specific gameplay (Chapters 1-3)
            if (chapter !== 4) {
                // Chapter 3: Canyon with winding trench
                const getTrenchOffset = (zPos) => {
                    const curveTime = time * 0.02;
                    // Add randomness to sine wave
                    const randomWobble = Math.sin(time * 0.05) * 100 + Math.cos(time * 0.03) * 80;
                    return Math.sin(curveTime + (zPos * 3)) * 250 + randomWobble;
                };

                if (chapter === 3 && time % 3 === 0) {
                    const offset = getTrenchOffset(0);
                    // Start MUCH wider, narrow progressively based on chapter time
                    const widthProgress = Math.min(chapterTimer / 600, 1); // 0 to 1 over 10 seconds
                    const trenchWidth = 1800 - (widthProgress * 900); // Start at 1800, narrow to 900
                    trenchBlocks.push({ worldLane: -trenchWidth/2 + offset, z: 0 });
                    trenchBlocks.push({ worldLane: trenchWidth/2 + offset, z: 0 });
                }
                
                // Chapter 2: Single obstacle blocks (Planetside hazards)
                if (chapter === 2 && Math.random() < 0.01) { // 1% chance per frame (~36 per minute at 60fps)
                    const lane = enemyWorldLanes[Math.floor(Math.random() * 7)];
                    trenchBlocks.push({ 
                        worldLane: lane, 
                        z: 0, 
                        isSingleBlock: true 
                    });
                }

                // Enemy spawning (all non-boss chapters)
                if (Math.random() < 0.02 + (gameSpeed * 0.1) + (level * 0.005)) {
                    if (chapter === 1) {
                        // Chapter 1: Drop from top of screen with random size
                        enemies.push({ 
                            x: Math.random() * (width - 200) + 100,
                            y: 0,
                            vx: 0,
                            vy: 4 + Math.random() * 2,
                            size: 30 + Math.random() * 30, // Random size 30-60
                            verticalDrop: true
                        });
                    } else {
                        let lane = enemyWorldLanes[Math.floor(Math.random() * 7)];
                        if (chapter === 3) {
                            const offset = getTrenchOffset(0);
                            lane = (Math.random() - 0.5) * 350 + offset;
                        }
                        enemies.push({ worldLane: lane, z: 0, size: 40 });
                    }
                }
                
                // Blockdot spawning (boomba carriers)
                if (Math.random() < 0.005 + (level * 0.001)) {
                    if (chapter === 1) {
                        // Chapter 1: Drop from top with lateral movement
                        enemies.push({ 
                            x: Math.random() * (width - 200) + 100,
                            y: 0,
                            vx: (Math.random() - 0.5) * 4, // Lateral movement: -2 to +2
                            vy: 3 + Math.random() * 2,
                            size: 35 + Math.random() * 20, // Slightly bigger
                            verticalDrop: true,
                            isBlockdot: true
                        });
                    } else {
                        let lane = enemyWorldLanes[Math.floor(Math.random() * 7)];
                        if (chapter === 3) {
                            const offset = getTrenchOffset(0);
                            lane = (Math.random() - 0.5) * 350 + offset;
                        }
                        enemies.push({ 
                            worldLane: lane, 
                            z: 0, 
                            size: 40,
                            lateralSpeed: (Math.random() - 0.5) * 300, // Side-to-side movement
                            lateralPhase: Math.random() * Math.PI * 2,
                            isBlockdot: true
                        });
                    }
                }

                // Pickup & heart spawning (shields only - weapons from mini-bosses)
                if (Math.random() < 0.008) {
                    if (chapter === 1) {
                        // Chapter 1: Drop from top of screen with random size
                        pickups.push({ 
                            x: Math.random() * (width - 200) + 100,
                            y: 0,
                            vx: 0,
                            vy: 3 + Math.random() * 2,
                            size: 20 + Math.random() * 15, // Random size 20-35
                            type: 'shield',
                            verticalDrop: true
                        });
                    } else {
                        pickups.push({ worldLane: enemyWorldLanes[Math.floor(Math.random() * 7)], z: 0, type: 'shield' });
                    }
                }
                if (Math.random() < 0.003) {
                    if (chapter === 1) {
                        // Chapter 1: Drop from top with random size
                        hearts.push({ 
                            x: Math.random() * (width - 200) + 100,
                            y: 0,
                            vx: 0,
                            vy: 3 + Math.random() * 2,
                            size: 15 + Math.random() * 10, // Random size 15-25
                            verticalDrop: true
                        });
                    } else {
                        hearts.push({ worldLane: enemyWorldLanes[Math.floor(Math.random() * 7)], z: 0 });
                    }
                }
                if (Math.random() < 0.001) {
                    if (chapter === 1) {
                        // Chapter 1: Drop from top with random size
                        pickups.push({ 
                            x: Math.random() * (width - 200) + 100,
                            y: 0,
                            vx: 0,
                            vy: 3 + Math.random() * 2,
                            size: 20 + Math.random() * 15,
                            type: 'invuln',
                            verticalDrop: true
                        });
                    } else {
                        pickups.push({ worldLane: enemyWorldLanes[Math.floor(Math.random() * 7)], z: 0, type: 'invuln' });
                    }
                }

                // Move objects forward
                enemies.forEach(e => {
                    if (e.verticalDrop) {
                        e.y += e.vy; // Fall straight down
                        e.x += e.vx; // Lateral movement for blockdots
                    } else {
                        e.z += 0.005 + (gameSpeed * 0.15); // 3D movement
                        
                        // Blockdots: smooth side-to-side movement
                        if (e.isBlockdot) {
                            e.lateralPhase += 0.05;
                            e.worldLane += Math.sin(e.lateralPhase) * e.lateralSpeed * 0.01;
                            // Keep within bounds
                            e.worldLane = Math.max(-450, Math.min(450, e.worldLane));
                        }
                    }
                });
                trenchBlocks.forEach(b => {
                    if (b.isSingleBlock) {
                        // Single blocks move at one third enemy speed
                        b.z += (0.005 + (gameSpeed * 0.15)) / 3;
                    } else {
                        // Normal trench walls (Chapter 3)
                        b.z += 0.03 + (gameSpeed * 0.2);
                    }
                });
                
                // Move pickups - different for chapter 1
                pickups.forEach(p => {
                    if (p.verticalDrop) {
                        p.y += p.vy; // Fall straight down
                    } else {
                        // Extra life pickups move at half enemy speed
                        if (p.type === 'extralife') {
                            p.z += (0.005 + (gameSpeed * 0.15)) * 0.5;
                        } else {
                            p.z += 0.005 + (gameSpeed * 0.1); // Normal speed
                        }
                    }
                });
                
                hearts.forEach(h => {
                    if (h.verticalDrop) {
                        h.y += h.vy; // Fall straight down
                    } else {
                        h.z += 0.005 + (gameSpeed * 0.1); // 3D movement
                    }
                });

                // Trench collision (Chapters 2 & 3)
                if ((chapter === 2 || chapter === 3) && trenchBlocks.length > 0) {
                    trenchBlocks.forEach((b, idx) => {
                        const bx = width/2 + b.worldLane * fovScale * b.z;
                        
                        // Single blocks (Ch2) have smaller collision area
                        const collisionWidth = b.isSingleBlock ? 50 : 120;
                        
                        if (b.z > 0.82 && Math.abs(shipX - bx) < collisionWidth) {
                            if (invulnerabilityTimer === 0) {
                                health--;
                                createDamageExplosion(shipX, shipY);
                                playSound(40, 'sawtooth', 0.8, 0.4);
                                trenchBlocks.splice(idx, 1);
                                if (health <= 0) {
                                    lives--;
                                    if (lives > 0) {
                                        // Respawn
                                        createUltimateExplosion(shipX, shipY);
                                        respawnTimer = 120; // 2 seconds
                                        health = 3;
                                        invulnerabilityTimer = 180;
                                    } else {
                                        createUltimateExplosion(shipX, shipY);
                                        deathTimer = 180;
                                        gameOver = true;
                                    }
                                }
                            }
                        }
                    });
                }

                // Bullets hitting enemies
                bullets.forEach((bull, bi) => {
                    // Bullets bounce off Chapter 2 single blocks (impervious!)
                    if (chapter === 2) {
                        trenchBlocks.forEach((b, bidx) => {
                            if (b.isSingleBlock) {
                                // Project obstacle to screen space
                                const bx = width/2 + b.worldLane * fovScale * b.z;
                                const by = height*0.3 + b.z * height*0.5;
                                
                                // 2D distance check
                                const dist = Math.hypot(bull.x - bx, bull.y - by);
                                const hitRadius = 40 + (b.z * 20); // Scale with depth
                                
                                if (dist < hitRadius) {
                                    // Bounce effect - just remove bullet with deflection sound
                                    bullets.splice(bi, 1);
                                    playSound(800, 'sine', 0.05, 0.06); // High ping sound
                                }
                            }
                        });
                    }
                    
                    enemies.forEach((e, ei) => {
                        let hit = false;
                        let ex, ey;
                        
                        if (e.verticalDrop) {
                            // Chapter 1: Vertical drop enemies - simple 2D collision
                            ex = e.x;
                            ey = e.y;
                            const dist = Math.hypot(bull.x - ex, bull.y - ey);
                            hit = dist < 50;
                        } else {
                            // Chapters 2-3: 3D lane enemies
                            // Project enemy to screen space and check 2D distance to bullet
                            ex = width/2 + e.worldLane * fovScale * e.z;
                            ey = height*0.3 + e.z * height*0.5;
                            
                            // Simple 2D distance check between bullet and enemy's screen position
                            const dist = Math.hypot(bull.x - ex, bull.y - ey);
                            
                            // Collision radius scales with enemy's z-depth (closer = larger hitbox)
                            const hitRadius = 30 + (e.z * 30); // Range: 30px (far) to 60px (close)
                            hit = dist < hitRadius;
                        }
                        
                        if (hit) {
                            playSound(150, 'sawtooth', 0.2, 0.1);
                            const explosionX = e.verticalDrop ? e.x : (width/2 + e.worldLane * fovScale * e.z);
                            const explosionY = e.verticalDrop ? e.y : (height*0.3 + e.z * height*0.5);
                            createExplosion(explosionX, explosionY);
                            
                            // Blockdots drop boombas!
                            if (e.isBlockdot) {
                                const boombaType = ['area', 'screen', 'charged'][Math.floor(Math.random() * 3)];
                                if (e.verticalDrop) {
                                    pickups.push({
                                        x: e.x,
                                        y: e.y,
                                        vx: 0,
                                        vy: 2,
                                        size: 25,
                                        type: 'boomba',
                                        boombaType: boombaType,
                                        verticalDrop: true
                                    });
                                    // 25% chance to also drop missile ammo
                                    if (Math.random() < 0.25) {
                                        pickups.push({
                                            x: e.x + 20,
                                            y: e.y,
                                            vx: 0,
                                            vy: 2.2,
                                            size: 20,
                                            type: 'missile',
                                            verticalDrop: true
                                        });
                                    }
                                } else {
                                    pickups.push({
                                        worldLane: e.worldLane,
                                        z: e.z,
                                        type: 'boomba',
                                        boombaType: boombaType
                                    });
                                    // 25% chance to also drop missile ammo
                                    if (Math.random() < 0.25) {
                                        pickups.push({
                                            worldLane: e.worldLane + 50,
                                            z: e.z,
                                            type: 'missile'
                                        });
                                    }
                                }
                                playSound(400, 'sine', 0.3, 0.15); // Special sound for boomba drop
                            }
                            
                            enemies.splice(ei, 1); 
                            bullets.splice(bi, 1);
                            score += e.isBlockdot ? 200 : 100; // Blockdots worth more
                            scoreEl.textContent = score;
                        }
                    });
                });

                // Pickup collection
                pickups.forEach((p, pi) => {
                    let px, py;
                    if (p.verticalDrop) {
                        px = p.x;
                        py = p.y;
                    } else {
                        px = width/2 + p.worldLane * fovScale * p.z;
                        py = height*0.3 + p.z * height*0.5;
                    }
                    
                    const canCollect = p.verticalDrop ? true : (p.z > 0.8);
                    
                    if (canCollect && Math.hypot(shipX - px, shipY - py) < 60) {
                        if (p.type === 'shield') {
                            shieldLevel = Math.min(100, shieldLevel + 20);
                        } else if (p.type === 'weapon') {
                            const newWeapon = Math.floor(Math.random() * 3) + 1; // 1-3
                            if (!weaponInventory.includes(newWeapon)) {
                                weaponInventory.push(newWeapon);
                            }
                        } else if (p.type === 'boomba') {
                            // Cap boomba queue at 40
                            if (boombaQueue.length < 40) {
                                boombaQueue.push(p.boombaType); // Use the type assigned when dropped
                            }
                        } else if (p.type === 'invuln') {
                            invulnerabilityTimer = 600; // 10 seconds
                        } else if (p.type === 'extralife') {
                            lives++; // Gain an extra life!
                            playSound(900, 'sine', 0.5, 0.3); // Special high-pitched sound
                        } else if (p.type === 'missile') {
                            missileAmmo = Math.min(maxMissileAmmo, missileAmmo + 2);
                            playSound(550, 'sine', 0.3, 0.2);
                        }
                        if (p.type !== 'extralife' && p.type !== 'missile') {
                            playSound(600, 'sine', 0.3, 0.2);
                        }
                        pickups.splice(pi, 1);
                    }
                });

                hearts.forEach((h, hi) => {
                    let hx, hy;
                    if (h.verticalDrop) {
                        hx = h.x;
                        hy = h.y;
                    } else {
                        hx = width/2 + h.worldLane * fovScale * h.z;
                        hy = height*0.3 + h.z * height*0.5;
                    }
                    
                    const canCollect = h.verticalDrop ? true : (h.z > 0.8);
                    
                    if (canCollect && Math.hypot(shipX - hx, shipY - hy) < 60) {
                        health = Math.min(maxHealth, health + 1);
                        playSound(800, 'sine', 0.3, 0.2);
                        hearts.splice(hi, 1);
                    }
                });

                // Enemy collision with player
                enemies.forEach((e, idx) => {
                    let ex, ey, colliding;
                    
                    if (e.verticalDrop) {
                        // Chapter 1: 2D collision
                        ex = e.x;
                        ey = e.y;
                        colliding = Math.hypot(shipX - ex, shipY - ey) < 60;
                    } else {
                        // Other chapters: 3D collision
                        ex = width/2 + e.worldLane * fovScale * e.z;
                        ey = height*0.3 + e.z * height*0.5;
                        colliding = e.z > 0.85 && Math.hypot(shipX - ex, shipY - ey) < 60;
                    }
                    
                    if (colliding) {
                        if (shieldActive || invulnerabilityTimer > 0) {
                            createExplosion(ex, ey);
                            
                            // Blockdots drop boombas even when shielded
                            if (e.isBlockdot) {
                                const boombaType = ['area', 'screen', 'charged'][Math.floor(Math.random() * 3)];
                                if (e.verticalDrop) {
                                    pickups.push({
                                        x: e.x,
                                        y: e.y,
                                        vx: 0,
                                        vy: 2,
                                        size: 25,
                                        type: 'boomba',
                                        boombaType: boombaType,
                                        verticalDrop: true
                                    });
                                } else {
                                    pickups.push({
                                        worldLane: e.worldLane,
                                        z: e.z,
                                        type: 'boomba',
                                        boombaType: boombaType
                                    });
                                }
                                playSound(400, 'sine', 0.3, 0.15);
                            }
                            
                            enemies.splice(idx, 1);
                            playSound(100, 'sine', 0.1, 0.2);
                        } else {
                            health--;
                            createDamageExplosion(shipX, shipY);
                            playSound(50, 'sawtooth', 0.5, 0.3);
                            
                            // Blockdots drop boombas on collision
                            if (e.isBlockdot) {
                                const boombaType = ['area', 'screen', 'charged'][Math.floor(Math.random() * 3)];
                                if (e.verticalDrop) {
                                    pickups.push({
                                        x: e.x,
                                        y: e.y,
                                        vx: 0,
                                        vy: 2,
                                        size: 25,
                                        type: 'boomba',
                                        boombaType: boombaType,
                                        verticalDrop: true
                                    });
                                } else {
                                    pickups.push({
                                        worldLane: e.worldLane,
                                        z: e.z,
                                        type: 'boomba',
                                        boombaType: boombaType
                                    });
                                }
                                playSound(400, 'sine', 0.3, 0.15);
                            }
                            
                            enemies.splice(idx, 1);
                            if (health <= 0) {
                                lives--;
                                if (lives > 0) {
                                    // Respawn
                                    createUltimateExplosion(shipX, shipY);
                                    respawnTimer = 120; // 2 seconds
                                    health = 3;
                                    invulnerabilityTimer = 180;
                                } else {
                                    createUltimateExplosion(shipX, shipY);
                                    deathTimer = 180;
                                    gameOver = true;
                                }
                            }
                        }
                    }
                });

                // Cleanup
                trenchBlocks = trenchBlocks.filter(b => b.z < 1.2);
                enemies = enemies.filter(e => e.verticalDrop ? e.y < height : e.z < 1.2);
                pickups = pickups.filter(p => p.verticalDrop ? p.y < height : p.z < 1.2);
                hearts = hearts.filter(h => h.verticalDrop ? h.y < height : h.z < 1.2);
            }

            // Update particles
            particles.forEach(p => { p.x += p.vx; p.y += p.vy; p.life--; p.vx *= 0.98; p.vy *= 0.98; });
            particles = particles.filter(p => p.life > 0);
            
            // Check chapter time limit (for chapters 1-3 only)
            if (chapter !== 4 && chapterTimer >= getChapterDuration()) {
                advanceChapter();
            }
            } catch (error) {
                console.error('Update error:', error);
                gameOver = true;
            }
        }

        function render() {
            try {
            ctx.fillStyle = '#000810';
            ctx.fillRect(0, 0, width, height);

            // Grid intensity - show in Planetside (ch2) and Canyon (ch3) only
            const showGrid = chapter === 2 || chapter === 3;
            if (showGrid) {
                const gridIntensity = 0.1 + (Math.abs(shipAngle) * 0.2) + (shieldActive ? 0.3 : 0);
                ctx.strokeStyle = `rgba(0, 255, 255, ${gridIntensity})`;
                ctx.shadowBlur = 10 * gridIntensity; ctx.shadowColor = '#00ffff';
                for(let i=-1000; i<=1000; i+=100) {
                    ctx.beginPath(); ctx.moveTo(width/2, height*0.3); ctx.lineTo(width/2+i, height); ctx.stroke();
                }
            }

            // Stars - different rendering per chapter
            if (chapter === 3) {
                // Chapter 3: Warp speed effect - stars move from horizon center outward
                const horizonX = width / 2;
                const horizonY = height * 0.3;
                
                stars.forEach(s => {
                    const dx = s.x - horizonX;
                    const dy = s.y - horizonY;
                    
                    // Move star outward from center
                    const angle = Math.atan2(dy, dx);
                    const speed = s.speed * 200; // Very fast warp speed (at least half boss bullet speed)
                    s.x += Math.cos(angle) * speed;
                    s.y += Math.sin(angle) * speed;
                    
                    // Reset if star goes off screen
                    if (s.x < 0 || s.x > width || s.y < 0 || s.y > height) {
                        s.x = horizonX + (Math.random() - 0.5) * 50;
                        s.y = horizonY + (Math.random() - 0.5) * 50;
                    }
                    
                    // Draw simple dot
                    ctx.fillStyle = '#fff';
                    ctx.shadowBlur = 0;
                    ctx.fillRect(s.x, s.y, s.z*3, s.z*3);
                });
            } else {
                // Other chapters: Normal star movement
                const starSpeedMultiplier = chapter === 4 ? 400 : 15; // Extremely fast in boss sector
                stars.forEach(s => { 
                    ctx.fillStyle = '#fff'; 
                    ctx.shadowBlur = 0; 
                    ctx.fillRect(s.x, s.y, s.z*3, s.z*3); 
                    s.y = (s.y + s.speed * starSpeedMultiplier) % height; 
                });
            }

            // Render Mini-Bosses
            miniBosses.forEach(mb => {
                ctx.strokeStyle = mb.color1;
                ctx.shadowColor = mb.color1;
                ctx.shadowBlur = 15;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(mb.x, mb.y - 15); ctx.lineTo(mb.x + 20, mb.y);
                ctx.lineTo(mb.x, mb.y + 15); ctx.lineTo(mb.x - 20, mb.y);
                ctx.closePath(); ctx.stroke();
                
                // Secondary color accent
                ctx.strokeStyle = mb.color2;
                ctx.shadowColor = mb.color2;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(mb.x, mb.y, 8, 0, Math.PI * 2);
                ctx.stroke();
                
                const barW = 80;
                ctx.fillStyle = '#440044';
                ctx.fillRect(mb.x - barW/2, mb.y - 30, barW, 4);
                ctx.fillStyle = mb.color1;
                ctx.fillRect(mb.x - barW/2, mb.y - 30, barW * (mb.hp / mb.maxHp), 4);
            });
            
            // Render mini-boss bullets
            miniBossBullets.forEach(mbb => {
                ctx.shadowBlur = 12;
                if (mbb.type === 'line') {
                    ctx.fillStyle = '#ff0000';
                    ctx.shadowColor = '#ff0000';
                    ctx.fillRect(mbb.x - 2, mbb.y, 4, 12);
                } else if (mbb.type === 'circle') {
                    ctx.fillStyle = '#ff6600';
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(mbb.x, mbb.y, 5, 0, Math.PI * 2);
                    ctx.fill();
                } else if (mbb.type === 'triangle') {
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowColor = '#ff00ff';
                    ctx.beginPath();
                    ctx.moveTo(mbb.x, mbb.y - 6);
                    ctx.lineTo(mbb.x + 5, mbb.y + 6);
                    ctx.lineTo(mbb.x - 5, mbb.y + 6);
                    ctx.closePath();
                    ctx.fill();
                }
            });

            // Render Missiles
            missiles.forEach(m => {
                // Calculate angle based on velocity/direction
                let angle = -Math.PI / 2; // Default pointing up
                
                if (m.bounced) {
                    // Bounced missile - tumbling, use velocity for base angle
                    angle = Math.atan2(m.bounceVy, m.bounceVx) + time * 0.5; // Tumble spin
                } else if (m.trail.length > 0) {
                    // Normal missile - point in direction of travel
                    const lastTrail = m.trail[m.trail.length - 1];
                    angle = Math.atan2(m.y - lastTrail.y, m.x - lastTrail.x);
                }
                
                // Draw trail (for both normal and bounced)
                ctx.shadowBlur = 8;
                m.trail.forEach((t, i) => {
                    const alpha = (i + 1) / m.trail.length * 0.6;
                    const size = 3 + (i / m.trail.length) * 4;
                    ctx.fillStyle = `rgba(255, 100, 0, ${alpha})`;
                    ctx.shadowColor = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(t.x, t.y, size, 0, Math.PI * 2);
                    ctx.fill();
                });
                
                // Draw missile body - SAME shape for both normal and bounced
                ctx.fillStyle = '#ff3300';
                ctx.shadowColor = '#ff6600';
                ctx.shadowBlur = 20;
                
                ctx.save();
                ctx.translate(m.x, m.y);
                ctx.rotate(angle + Math.PI / 2);
                
                // Missile shape
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.lineTo(-6, 8);
                ctx.lineTo(0, 4);
                ctx.lineTo(6, 8);
                ctx.closePath();
                ctx.fill();
                
                // Engine glow
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.beginPath();
                ctx.arc(0, 6, 3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            });

            // Render Boss
            harassers.forEach(h => {
                ctx.strokeStyle = '#ff00ff';
                ctx.shadowColor = '#ff00ff';
                ctx.shadowBlur = 20;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(h.x, h.y - 20); ctx.lineTo(h.x + 30, h.y);
                ctx.lineTo(h.x, h.y + 20); ctx.lineTo(h.x - 30, h.y);
                ctx.closePath(); ctx.stroke();
                const barW = 120;
                ctx.fillStyle = '#440044';
                ctx.fillRect(h.x - barW/2, h.y - 45, barW, 6);
                ctx.fillStyle = '#ff00ff';
                ctx.fillRect(h.x - barW/2, h.y - 45, barW * (h.hp / h.maxHp), 6);
            });

            harasserBullets.forEach(hb => {
                ctx.fillStyle = '#ff00ff';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ff00ff';
                ctx.fillRect(hb.x - 2, hb.y, 4, 15);
            });

            // Trench walls - larger size to match wider trench
            trenchBlocks.forEach(b => {
                const bx = width/2 + b.worldLane * fovScale * b.z;
                const by = height*0.3 + b.z * height*0.5;
                
                if (b.isSingleBlock) {
                    // Chapter 2: Single obstacle blocks (half size of trench walls)
                    const sz = 90 * b.z; // Half of 180
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + Math.random()*0.3})`;
                    ctx.shadowBlur = 20; 
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(bx, by - sz);
                    ctx.lineTo(bx + sz/1.5, by);
                    ctx.lineTo(bx - sz/1.5, by);
                    ctx.closePath();
                    ctx.fill();
                } else {
                    // Chapter 3: Trench walls (larger triangular walls)
                    const sz = 180 * b.z;
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.7 + Math.random()*0.3})`;
                    ctx.shadowBlur = 15; 
                    ctx.shadowColor = '#ffffff';
                    ctx.beginPath();
                    ctx.moveTo(bx, by - sz);
                    ctx.lineTo(bx + sz/1.5, by);
                    ctx.lineTo(bx - sz/1.5, by);
                    ctx.closePath();
                    ctx.fill();
                }
            });

            bullets.forEach(b => {
                // All chapters now use Y coordinates
                const bY = b.y;
                let bSize = 4; // Base size
                let bLength = 35; // Base length
                
                // Chapters 2 & 3: Scale bullets based on distance to horizon (perspective)
                if ((chapter === 2 || chapter === 3) && b.distanceToHorizon !== undefined) {
                    // Scale from 1.0 (full size) at ship position to 0.1 (tiny) near horizon
                    // Max distance is roughly from bottom to horizon (~400px)
                    const maxDistance = 400;
                    const normalizedDistance = Math.min(b.distanceToHorizon / maxDistance, 1);
                    const scale = 0.2 + (normalizedDistance * 0.8); // Range: 0.2 to 1.0
                    
                    bSize *= scale;
                    bLength *= scale;
                }
                
                ctx.shadowBlur = 15;
                
                // Render based on type
                if (b.type === 'bounced') {
                    // Bounced bullets - yellow, fading out
                    const alpha = b.bounceLife / 60;
                    ctx.fillStyle = `rgba(255, 255, 0, ${alpha})`;
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 10 * alpha;
                    
                    // Draw as a small spinning projectile
                    ctx.save();
                    ctx.translate(b.x, b.y);
                    ctx.rotate(time * 0.3); // Spin effect
                    ctx.fillRect(-3, -3, 6, 6);
                    ctx.restore();
                } else if (b.type === 'vertical-laser') {
                    ctx.fillStyle = '#00ffff';
                    ctx.shadowColor = '#00ffff';
                    ctx.fillRect(b.x - (b.width || 4) * (bSize/4), bY, (b.width || 4) * (bSize/2), 40 * (bLength/35));
                } else if (b.type === 'vertical-scatter') {
                    ctx.fillStyle = '#ff00ff';
                    ctx.shadowColor = '#ff00ff';
                    ctx.fillRect(b.x - bSize, bY, bSize * 2, 25 * (bLength/35));
                } else if (b.type === 'vertical-sine') {
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.fillRect(b.x - bSize/2, bY, bSize, 30 * (bLength/35));
                } else {
                    // Default vertical bullet - yellow streak
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.fillRect(b.x - bSize/2, bY, bSize, bLength);
                }
            });

            pickups.forEach(p => {
                let sz, px, py;
                
                if (p.verticalDrop) {
                    // Chapter 1: Render at actual screen position with random size
                    sz = p.size || 25;
                    px = p.x;
                    py = p.y;
                } else {
                    // Other chapters: 3D perspective
                    sz = 25 * p.z;
                    px = width/2 + p.worldLane * fovScale * p.z;
                    py = height*0.3 + p.z * height*0.5;
                }
                
                ctx.shadowBlur = 15;
                ctx.font = '12px Courier New';
                ctx.textAlign = 'center';
                
                if (p.type === 'weapon') {
                    ctx.strokeStyle = '#00ffff';
                    ctx.shadowColor = '#00ffff';
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(px, py, sz, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillText('W', px, py + 4);
                } else if (p.type === 'boomba') {
                    ctx.strokeStyle = '#ff6600';
                    ctx.shadowColor = '#ff6600';
                    ctx.fillStyle = '#ff6600';
                    ctx.beginPath();
                    ctx.arc(px, py, sz, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillText('B', px, py + 4);
                } else if (p.type === 'invuln') {
                    ctx.strokeStyle = '#ffffff';
                    ctx.shadowColor = '#ffffff';
                    ctx.fillStyle = '#ffffff';
                    ctx.beginPath();
                    ctx.arc(px, py, sz, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillText('I', px, py + 4);
                } else if (p.type === 'extralife') {
                    // Draw ship icon in a circle (like other powerups)
                    ctx.strokeStyle = '#00ffff';
                    ctx.shadowColor = '#00ffff';
                    ctx.fillStyle = '#00ffff';
                    ctx.beginPath();
                    ctx.arc(px, py, sz, 0, Math.PI * 2);
                    ctx.stroke();
                    
                    // Draw tiny ship inside
                    ctx.save();
                    ctx.translate(px, py);
                    const scale = sz / 80; // Much smaller scale for icon
                    ctx.scale(scale, scale);
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    ctx.moveTo(0, -25);
                    ctx.lineTo(-30, 10);
                    ctx.lineTo(0, 5);
                    ctx.lineTo(30, 10);
                    ctx.closePath();
                    ctx.stroke();
                    ctx.restore();
                } else if (p.type === 'shield') {
                    // Shield: yellow circle with lowercase 's'
                    ctx.strokeStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.fillStyle = '#ffff00';
                    ctx.beginPath();
                    ctx.arc(px, py, sz, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillText('s', px, py + 4);
                } else if (p.type === 'missile') {
                    ctx.strokeStyle = '#ff3300';
                    ctx.shadowColor = '#ff6600';
                    ctx.fillStyle = '#ff3300';
                    ctx.beginPath();
                    ctx.arc(px, py, sz, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillText('M', px, py + 4);
                }
            });

            hearts.forEach(h => {
                let sz, hx, hy;
                
                if (h.verticalDrop) {
                    // Chapter 1: Render at actual screen position with random size
                    sz = h.size || 20;
                    hx = h.x;
                    hy = h.y;
                } else {
                    // Other chapters: 3D perspective
                    sz = 20 * h.z;
                    hx = width/2 + h.worldLane * fovScale * h.z;
                    hy = height*0.3 + h.z * height*0.5;
                }
                
                ctx.strokeStyle = '#00ff00';
                ctx.shadowColor = '#00ff00';
                ctx.shadowBlur = 15;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(hx, hy + sz/4);
                ctx.bezierCurveTo(hx, hy - sz/4, hx - sz, hy - sz/4, hx - sz, hy + sz/4);
                ctx.bezierCurveTo(hx - sz, hy + sz, hx, hy + sz * 1.2, hx, hy + sz * 1.5);
                ctx.bezierCurveTo(hx, hy + sz * 1.2, hx + sz, hy + sz, hx + sz, hy + sz/4);
                ctx.bezierCurveTo(hx + sz, hy - sz/4, hx, hy - sz/4, hx, hy + sz/4);
                ctx.stroke();
            });

            enemies.forEach(e => {
                let sz, ex, ey;
                
                if (e.verticalDrop) {
                    // Chapter 1: Render at actual screen position
                    sz = e.size;
                    ex = e.x;
                    ey = e.y;
                } else {
                    // Other chapters: 3D perspective
                    sz = e.size * e.z;
                    ex = width/2 + e.worldLane * fovScale * e.z;
                    ey = height*0.3 + e.z * height*0.5;
                }
                
                // Blockdots have special rendering
                if (e.isBlockdot) {
                    ctx.strokeStyle = '#ff6600'; 
                    ctx.shadowColor = '#ff6600';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(ex-sz, ey-sz, sz*2, sz*2);
                    
                    // Draw center dot
                    ctx.fillStyle = '#ffff00';
                    ctx.shadowColor = '#ffff00';
                    ctx.shadowBlur = 15;
                    ctx.beginPath();
                    ctx.arc(ex, ey, sz * 0.3, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // Regular enemies
                    ctx.strokeStyle = '#ff3333'; 
                    ctx.shadowColor = '#ff0000';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(ex-sz, ey-sz, sz*2, sz*2);
                }
            });

            ctx.shadowBlur = 0;
            particles.forEach(p => {
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life/60;
                ctx.fillRect(p.x, p.y, 3, 3);
            });
            ctx.globalAlpha = 1;

            // Shield & Health bars
            ctx.strokeStyle = '#333'; ctx.strokeRect(width - 40, height*0.3, 15, height*0.4);
            ctx.fillStyle = '#ffff00'; ctx.fillRect(width - 40, height*0.7, 15, -(height*0.4 * (shieldLevel/100)));

            const healthBarX = width - 70;
            ctx.strokeStyle = '#333'; 
            ctx.strokeRect(healthBarX, height*0.3, 15, height*0.4);
            ctx.fillStyle = '#00ff00'; 
            ctx.fillRect(healthBarX, height*0.7, 15, -(height*0.4 * (health/maxHealth)));

            if(!gameOver && respawnTimer === 0) {
                ctx.save();
                ctx.translate(shipX, shipY);
                ctx.rotate(shipAngle * 0.2);
                
                // Invulnerability effect
                if (invulnerabilityTimer > 0) {
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 2;
                    ctx.globalAlpha = 0.3 + Math.sin(time * 0.5) * 0.3;
                    ctx.beginPath();
                    ctx.arc(0, 0, 85, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                if(shieldActive) {
                    ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 2; ctx.beginPath();
                    ctx.arc(0, 0, 75 + Math.sin(time*0.5)*5, 0, Math.PI*2); ctx.stroke();
                }
                
                // Charging boomba effect
                if (chargingBoomba) {
                    ctx.strokeStyle = '#ff6600';
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.5 + (boombaCharge / 300) * 0.5;
                    ctx.beginPath();
                    ctx.arc(0, 0, 60 + (boombaCharge / 300) * 40, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }
                
                ctx.strokeStyle = '#00ffff'; ctx.lineWidth = 3; ctx.shadowColor = '#00ffff'; ctx.shadowBlur = 20;
                ctx.beginPath(); ctx.moveTo(0,-35); ctx.lineTo(-45,15); ctx.lineTo(0,5); ctx.lineTo(45,15); ctx.closePath(); ctx.stroke();
                ctx.restore();
                
                // Missile lock-on indicator
                if (missileAmmo > 0 && missileCooldown === 0) {
                    const targetInfo = findMissileTarget();
                    if (targetInfo) {
                        const target = targetInfo.target;
                        ctx.strokeStyle = '#ff3300';
                        ctx.shadowColor = '#ff6600';
                        ctx.shadowBlur = 15;
                        ctx.lineWidth = 2;
                        
                        const pulseSize = 25 + Math.sin(time * 0.2) * 5;
                        
                        ctx.beginPath();
                        ctx.moveTo(target.x - pulseSize, target.y - pulseSize + 10);
                        ctx.lineTo(target.x - pulseSize, target.y - pulseSize);
                        ctx.lineTo(target.x - pulseSize + 10, target.y - pulseSize);
                        ctx.moveTo(target.x + pulseSize - 10, target.y - pulseSize);
                        ctx.lineTo(target.x + pulseSize, target.y - pulseSize);
                        ctx.lineTo(target.x + pulseSize, target.y - pulseSize + 10);
                        ctx.moveTo(target.x + pulseSize, target.y + pulseSize - 10);
                        ctx.lineTo(target.x + pulseSize, target.y + pulseSize);
                        ctx.lineTo(target.x + pulseSize - 10, target.y + pulseSize);
                        ctx.moveTo(target.x - pulseSize + 10, target.y + pulseSize);
                        ctx.lineTo(target.x - pulseSize, target.y + pulseSize);
                        ctx.lineTo(target.x - pulseSize, target.y + pulseSize - 10);
                        ctx.stroke();
                        
                        ctx.fillStyle = '#ff3300';
                        ctx.font = 'bold 10px Courier New';
                        ctx.textAlign = 'center';
                        ctx.fillText('LOCK', target.x, target.y + pulseSize + 12);
                    }
                }
            }

            if (gameOver && deathTimer === 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.9)'; 
                ctx.fillRect(0,0,width,height);
                ctx.textAlign = 'center';
                
                // GAME OVER - big red with glow
                ctx.font = 'bold 64px Courier New';
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ff0000';
                ctx.fillStyle = '#ff0000';
                ctx.fillText('GAME OVER', width/2, height/2 - 140);
                
                // APOPHIS STEERING COMMITTEE - magenta like title
                ctx.font = '16px Courier New';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff00ff';
                ctx.fillStyle = '#ff00ff';
                ctx.fillText('APOPHIS STEERING COMMITTEE-26', width/2, height/2 - 90);
                
                // EARTH DEFENSE FAILURE — APOPHIS ADVANCES - yellow warning
                ctx.font = 'bold 20px Courier New';
                ctx.shadowBlur = 15;
                ctx.shadowColor = '#ffff00';
                ctx.fillStyle = '#ffff00';
                ctx.fillText('EARTH DEFENSE FAILURE — APOPHIS ADVANCES', width/2, height/2 - 40);
                
                // FINAL SCORE label
                ctx.font = '18px Courier New';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#888888';
                ctx.fillStyle = '#888888';
                ctx.fillText('FINAL SCORE', width/2, height/2 + 20);
                
                // Score with color cycling glow like title
                const hue = (time * 2) % 360;
                ctx.font = 'bold 56px Courier New';
                ctx.shadowBlur = 35;
                ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                ctx.fillStyle = '#00ffff';
                ctx.fillText(`${score} PTS`, width/2, height/2 + 80);
                
                // PRESS -R- TO RESTART - blinking
                const blink = Math.sin(time * 0.08) > 0;
                if (blink) {
                    ctx.font = '20px Courier New';
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = '#00ffff';
                    ctx.fillStyle = '#00ffff';
                    ctx.fillText('PRESS -R- TO RESTART', width/2, height/2 + 150);
                }
                ctx.shadowBlur = 0;
            }
            
            if (levelTransitionTimer > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)'; 
                ctx.fillRect(0,0,width,height);
                ctx.fillStyle = '#00ff00'; 
                ctx.shadowBlur = 30;
                ctx.shadowColor = '#00ff00';
                ctx.font = 'bold 48px Courier New'; 
                ctx.textAlign = 'center';
                ctx.fillText(`LEVEL ${level - 1} COMPLETE`, width/2, height/2 - 100);
                ctx.font = 'bold 32px Courier New';
                ctx.fillStyle = '#ffff00';
                ctx.shadowColor = '#ffff00';
                ctx.fillText(`BOSS DEFEATED: +${bossScoreGained} POINTS`, width/2, height/2 - 40);
                
                // Score display with color cycling like title screen
                const hue = (time * 2) % 360;
                ctx.font = 'bold 36px Courier New';
                ctx.shadowBlur = 25;
                ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                ctx.fillStyle = '#00ffff';
                ctx.fillText(`YOU'VE AMASSED ${score} PTS`, width/2, height/2 + 30);
                
                ctx.font = 'bold 36px Courier New';
                ctx.fillStyle = '#00ffff';
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 30;
                ctx.fillText(`ENTERING LEVEL ${level}`, width/2, height/2 + 100);
                ctx.shadowBlur = 0;
            }
            
            if (bossDefeatedTimer > 0) {
                // Just show the spectacular explosion, no text yet
                ctx.fillStyle = 'rgba(0,0,0,0.1)'; 
                ctx.fillRect(0,0,width,height);
            }
            
            if (chapterTransitionTimer > 0) {
                ctx.fillStyle = 'rgba(0,0,0,0.6)'; 
                ctx.fillRect(0,0,width,height);
                ctx.fillStyle = '#ffff00'; 
                ctx.shadowBlur = 25;
                ctx.shadowColor = '#ffff00';
                ctx.font = 'bold 40px Courier New'; 
                ctx.textAlign = 'center';
                const chapterNames = ['OPEN SPACE', 'PLANETSIDE', 'TRENCH CANYON', 'BOSS SECTOR'];
                ctx.fillText(`CHAPTER ${chapter}: ${chapterNames[chapter - 1]}`, width/2, height/2 - 30);
                
                // Score display with color cycling like title screen
                const hue = (time * 2) % 360;
                ctx.font = 'bold 28px Courier New';
                ctx.shadowBlur = 20;
                ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
                ctx.fillStyle = '#00ffff';
                ctx.fillText(`YOU'VE AMASSED ${score} PTS`, width/2, height/2 + 30);
                ctx.shadowBlur = 0;
            }
            
            renderHUD();
            } catch (error) {
                console.error('Render error:', error);
            }
        }
        
        function renderHUD() {
            ctx.shadowBlur = 0;
            ctx.font = '14px Courier New';
            ctx.textAlign = 'left';
            
            // Weapon display
            const weaponNames = ['DEFAULT', 'SINE WAVE', 'SCATTER', 'LASER'];
            const weaponName = weaponNames[weaponInventory[currentWeapon]] || 'DEFAULT';
            ctx.fillStyle = '#00ffff';
            ctx.fillText(`WEAPON: ${weaponName}`, 20, height - 100);
            
            // Missiles
            ctx.fillStyle = missileAmmo <= 2 ? '#ff3300' : '#ff6600';
            ctx.fillText(`MISSILES: ${missileAmmo}/${maxMissileAmmo}`, 20, height - 80);
            
            // Boombas - show queue with max capacity
            ctx.fillStyle = '#ff6600';
            ctx.fillText(`BOOMBAS: ${boombaQueue.length}/40`, 20, height - 60);
            
            if (boombaQueue.length > 0) {
                // Show first 3 in queue
                const display = boombaQueue.slice(0, 3).map((b, idx) => {
                    const labels = { area: 'AREA', screen: 'SCREEN', charged: 'CHARGED' };
                    return idx === 0 ? `[${labels[b]}]` : labels[b];
                }).join(' → ');
                ctx.fillStyle = '#ffaa66';
                ctx.fillText(display, 20, height - 40);
            }
            
            // Invulnerability
            if (invulnerabilityTimer > 0) {
                ctx.fillStyle = '#ffffff';
                ctx.fillText(`INVULN: ${Math.ceil(invulnerabilityTimer / 60)}s`, 20, height - 20);
            }
            
            // Position icons to the left of the health bar
            const healthBarX = width - 70;
            const iconAreaRightEdge = healthBarX - 30; // 30px gap from health bar
            
            // Lives indicator - tiny ship icons stacked vertically
            ctx.shadowBlur = 0;
            const shipIconSize = 0.4;
            const verticalSpacing = 20;
            const lifeIconsX = iconAreaRightEdge - 20; // X position for life icons
            const lifeIconsStartY = height * 0.35; // Start higher up
            
            for (let i = 0; i < lives; i++) {
                const x = lifeIconsX;
                const y = lifeIconsStartY + i * verticalSpacing;
                
                ctx.save();
                ctx.translate(x, y);
                ctx.scale(shipIconSize, shipIconSize);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 3;
                ctx.shadowColor = '#00ffff';
                ctx.shadowBlur = 15;
                ctx.beginPath();
                ctx.moveTo(0, -35);
                ctx.lineTo(-45, 15);
                ctx.lineTo(0, 5);
                ctx.lineTo(45, 15);
                ctx.closePath();
                ctx.stroke();
                ctx.restore();
            }
            
            // Upgrade icons stacked below ship lives
            let upgradeX = lifeIconsX;
            let upgradeY = lifeIconsStartY + (lives * verticalSpacing) + 15;
            const iconSize = 10;
            const iconSpacing = 18;
            
            ctx.shadowBlur = 0;
            ctx.lineWidth = 2;
            
            // Weapon icons - stacked vertically
            const weaponIcons = ['D', 'S', 'C', 'L'];
            for (let idx = 0; idx < weaponInventory.length; idx++) {
                const weaponId = weaponInventory[idx];
                const isActive = idx === currentWeapon;
                ctx.fillStyle = isActive ? '#00ffff' : '#004444';
                ctx.strokeStyle = isActive ? '#00ffff' : '#004444';
                
                // Draw circle
                ctx.beginPath();
                ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
                ctx.stroke();
                
                // Draw letter
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(weaponIcons[weaponId], upgradeX, upgradeY);
                
                upgradeY += iconSpacing;
            }
            
            // Boomba queue icons - show first 5 slots
            if (true) { // Always show boomba slots
                upgradeY += 5; // Small gap
                
                const slotsToShow = Math.min(5, Math.max(3, boombaQueue.length)); // Show 3-5 slots
                
                for (let i = 0; i < slotsToShow; i++) {
                    const hasBoomba = i < boombaQueue.length;
                    const boomba = hasBoomba ? boombaQueue[i] : null;
                    const isNext = i === 0 && hasBoomba;
                    const isCharging = isNext && chargingBoomba;
                    
                    if (hasBoomba) {
                        // Determine color and label
                        let letter, baseColor;
                        if (boomba === 'area') {
                            letter = 'A';
                            baseColor = '#ff6600';
                        } else if (boomba === 'screen') {
                            letter = 'S';
                            baseColor = '#ff0000';
                        } else { // charged
                            letter = 'C';
                            baseColor = '#ff6600';
                        }
                        
                        // Highlight next boomba
                        const color = isCharging ? '#ffff00' : (isNext ? '#ffaa66' : baseColor);
                        const alpha = isNext ? 1 : 0.5;
                        
                        ctx.globalAlpha = alpha;
                        ctx.fillStyle = color;
                        ctx.strokeStyle = color;
                        ctx.lineWidth = isNext ? 3 : 2;
                        
                        ctx.beginPath();
                        ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.font = 'bold 12px Courier New';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(letter, upgradeX, upgradeY);
                        
                        ctx.globalAlpha = 1;
                    } else {
                        // Empty slot
                        ctx.globalAlpha = 0.2;
                        ctx.strokeStyle = '#666666';
                        ctx.lineWidth = 1;
                        
                        ctx.beginPath();
                        ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        ctx.globalAlpha = 1;
                    }
                    
                    upgradeY += iconSpacing;
                }
                
                // If more than 5 boombas, show "+X more" indicator
                if (boombaQueue.length > 5) {
                    ctx.fillStyle = '#ff6600';
                    ctx.globalAlpha = 0.7;
                    ctx.font = 'bold 10px Courier New';
                    ctx.textAlign = 'center';
                    ctx.fillText(`+${boombaQueue.length - 5}`, upgradeX, upgradeY);
                    ctx.globalAlpha = 1;
                }
            }
            
            // Invulnerability icon
            if (invulnerabilityTimer > 0) {
                upgradeY += 5;
                const pulseAlpha = 0.5 + Math.sin(time * 0.3) * 0.5;
                ctx.globalAlpha = pulseAlpha;
                ctx.fillStyle = '#ffffff';
                ctx.strokeStyle = '#ffffff';
                ctx.beginPath();
                ctx.arc(upgradeX, upgradeY, iconSize, 0, Math.PI * 2);
                ctx.stroke();
                ctx.font = 'bold 12px Courier New';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('I', upgradeX, upgradeY);
                ctx.globalAlpha = 1;
            }
        }

        function loop(currentTime) {
            if (!lastFrameTime) lastFrameTime = currentTime;
            
            const deltaTime = currentTime - lastFrameTime;
            lastFrameTime = currentTime;
            
            // Accumulate time and run fixed updates
            accumulator += deltaTime;
            
            // Cap accumulator to prevent spiral of death on slow machines
            if (accumulator > FRAME_DURATION * 5) {
                accumulator = FRAME_DURATION * 5;
            }
            
            // Run game logic at fixed 60 FPS
            while (accumulator >= FRAME_DURATION) {
                update();
                accumulator -= FRAME_DURATION;
            }
            
            // Always render
            render();
            
            requestAnimationFrame(loop);
        }

        window.addEventListener('resize', resize);
    </script>
</body>
</html